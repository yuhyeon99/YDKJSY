> 프로그램 전체에 적용되는 결정 사항의 패턴을 알아봅시다.
어떻게 그리고 왜 함수와 블록을 사용해 프로그램 내 변수를 다양한 스코프로 구성해야 하는지를 ‘스코프 과다 노출 제한’ 관점에서 알아보겠습니다.
> 

### 6.1 최소 노출의 원칙(POLE)

- 블록 스코프가 왜 필요한걸까?
- POLE(최소 노출의 원칙)을 준수하기 위해서 필요한 개념이다.
- POLE(Principle Of Least Exposure)란?
    - POLP(Principle Of Least Privilege)을 약간 변형한 원칙이다.
        - 시스템 구성 요소에는 최소한의 권한을 부여하고 접근도 최소화하며 노출 역시 최소화해야 한다는 설계 원칙. **방어적인 아키텍처 설계를 대변**함
        - POLP를 기반으로 아키텍처를 설계해 각 구성 요소가 필요한 최소한의 기능으로 연결되면, **한 구성 요소의 손상이나 장애가 나머지 시스템에 미치는 영향이 최소화**되므로 시스템 전체 보안이 더 강력해진다는 장점이 있음.
    - POLP의 변형인 POLE은 조금 더 낮은 수준의 설계에 집중
    - POLE을 따른다고 했을 때 최소화하고 싶은 항목은 **스코프마다 등록된 변수의 노출**
- 프로그램의 모든 변수를 전역 스코프에 배치하면 안 되는 이유
    1. 이름 충돌:
        - 범용적인 이름을 가진 변수/함수를 사용하면서 전역 스코프에 2개 이상 동일하게 등록되어 있다면, 이름 충돌이 발생한다.
        - 이런 방식은 예상치 못한 방식으로 변수나 함수를 사용할 수 있어 버그가 발생할 확률이 매우 높음
        - 예) 모든 반복문에서 하나의 전역 인덱스용 변수 i를 사용한다고 가정했을 때, A라는 함수의 반복문이 B라는 함수의 반복문과 동시에 실행되는 경우, 공유된 변수 i가 예상치 못한 값으로 변경될 수 있음.
    2. 예기치 않은 작동:
        - 비공개(private) 변수/함수를 프로그램 내부에 노출하면, 다른 개발자가 의도하지 않은 방식으로 변수나 함수를 사용할 수 있음.
            - 비굥개 변수/함수를 프로그램 내부에 노출하지 못하게 하는 대표적인 방법으론 `클로저`가 있음
            
            ```jsx
            function closerEx() {
            	let count = 0;
            	
            	function increase() {
            		count ++;
            		console.log(count);
            	}
            	
            	return increase;
            }
            
            const firstCloser = closerEx();
            firstCLoser();
            ```
            
        - 예) 숫자만 관리하는 배열이 따로 있고, 숫자를 사용하고 싶을 때는 이 배열에 접근해서 숫자를 얻어온다고 가정했을 때, 이 배열에 불리언이나 문자열을 추가할 수 있다면 우리의 코드는 예기치 않게 오작동할 수 있음. 
        예2) 개인 정보를 담고 있는 변수나 함수가 노출되면 악의를 가진 이들이 우리가 설정한 제한을 우회해 도용할 수 있음
    3. 의도치 않은 종속성
        - 변수나 함수가 불필요하게 노출되면 다른 개발자가 비공개로 처리된 변수/함ㅅ ㅜ를 사용하고 여기에 의존하기까지 할 수 있음
        - 이런 행동이 당장 프로그램을 손상하지는 않지만, 향후 리팩터링 시 좋지 않음
- POLE를 준수한 코드 예시
    
    ```jsx
    function diff(x, y) {
    	if (x > y) {
    		let tmp = x; // tmp는 여기서만 필요함
    		x = y;
    		y = tmp;
    	}
    	return y - x;
    }
    ```
    
    - `diff` 함수에서 반환값`(y-x)`이 0보다 크거나 같게 하려면 `y`가 `x`보다 크거나 같아야함
    - `x`가 `y`보다 더 크면 반환값이 음수가 되므로 이를 방지하기 위해 `tmp` 변수를 사용해 `x`와 `y`를 바꿔 차를 구함
    - `tmp`가 `if` 블록 안에 있든 함수 수준에 속해 있든 중요하지 않아 보일 수 있지만, tmp는 전역 변수가 되어서는 안됨.
    - `tmp`는 POLE에 따라 스코프 내에 최대한 숨겨져 있어야 합니다.
        - 변수를 사용하는 범위를 제한하면, **해당 변수가 왜 필요한지, 어디서 사용되는지 더 명확**하게 드러납니다.
        - `tmp`가 `if` 블록 안에 있으면 **이 변수는 해당 블록 안에서만 사용된다는 의도가 명확**합니다.
    - 이렇게 `if` 블록 안에서 `let`을 사용해 `tmp`를 선언하면 `tmp`의 스코프를 블록으로 차단할 수 있습니다.

### 6.2 일반(함수) 스코프에 숨기기

- 가능한 한 가장 낮은 스코프(가장 깊은 중첩 스코프)에 변수와 함수 선언을 숨기는 함수 스코프에 관련된 내용
- 함수 스코프 지정이 유용한 경우
    - 계승(팩토리얼(!로 표기))
        - 1에서 n까지의 모든 정수를 곱하는 것.
        - 계승에서는 한 번 계산된 정수의 계승을 다시 계산할 필요가 없음
        - 이는 캐시에 저장하여 메모리를 희생하긴 하지만 대신 계산 낭비를 없애 속도를 높일 수 있음
    - **예제 코드:**
    
    ```jsx
    var cache = {};
    
    function factorial(x) {
    	if (x < 2) return 1;
    	if (!(x in cache)) { // 캐시 객체 안에 계산한 정수의 계승이 있는지 확인
    		cache[x] = x * factorial(x - 1);
    	}
    	return cache[x];
    }
    
    factorial(6);
    // 호출 스택에 쌓이는 순서: 1 2 3 4 5 6
    // 호출 스택에서 실행되는 순서: 6 5 4 3 2 1
    // 1. cache[6] = 6 * factorial(5); => 6 * 120 = 720 최종 값 
    // 2. cache[5] = 5 * factorial(4); => 5 * 24 = 120
    // 3. cache[4] = 4 * factorial(3); => 4 * 6 = 24
    // 4. cache[3] = 3 * factorial(2); => 3 * 2 = 6
    // 5. cache[2] = 2 * factorial(1); => 2 * 1 = 2
    // 6. return 1;
    
    factorial(7)
    // 5040, 재귀함수 한번 호출한 후 cache[6]를 바로 반환받아서
    // 7 * 720 = 5040 으로 계산 낭비를 없앰
    ```
    
    - 여기서 주목해야 할 점은 cache 변수는 `factorial()`의 작동 방식을 나타내는 비공개 변수라는 점.
        - 외부 스코프, 특히 전역 스코프에 있는 변수가 아니므로 노출되면 안 되는 비밀스러운 변수
    - 그런데 `cache` 변수를 `factorial()` 함수 내부로 숨기는 것으로는 문제를 해결할 수 없음
        - `cache` 변수는 호출이 여러 번 일어나는 경우에도 유지되어야 하므로 함수 외부 스코프에 있어야 하기 때문.
    - **해결책:**
        
        > 외부/전역 스코프와 내부 `factorial()` 사이에 `cache` 가 위치할 중간 스코프를 정의하면 됩니다.(클로저)
        > 
        
        ```jsx
        // 외부/전역 스코프
        
        function hideTheCache() {
        	// cache를 숨길 중간 스코프
        	var cache = {};
        	
        	return factorial;
        	// ************************
        	
        	function factorial(x) {
        		// inner scope
        		if (x < 2) return 1;
        		if (!(x in cache)) { // 캐시 객체 안에 계산한 정수의 계승이 있는지 확인
        			cache[x] = x * factorial(x - 1);
        		}
        		return cache[x];
        	}
        }
        
        var factorial = hideTheCache(); // 인스턴스 생성
        
        factorial(6);
        // 720
        
        factorial(7);
        // 5040
        ```
        
    - `hideTheCache()` 함수는 `factorial()`을 여러 번 호출하는 동안 `cache`를 지속시킬 스코프를 만드는 것 외에는 용도가 없습니다.
    - `factorial()`이 `cache`에 접근할 수 있게 하려면 동일한 스코프에 `factorial()`을 정의해야 함.
    - 그 다음 `hideTheCache()`에서 `factorial` 함수를 반환하도록 하고 이 함수 참조를 외부 스코프인 `factorial` 변수에 저장합니다.(=클로저)
    - 변수나 함수를 숨겨야 하는 상황이 생기면(`hideTheCache`함수를 숨기고 싶을 때) 특이한 이름을 가진 함수를 정의하는 것보다 함수 표현식을 사용하는  게 더 나은 해결책이 될 수 있습니다.
    
    ```jsx
    var factorial = (function hideTheCache() {
    	// 위 예제의 hideTheCache 함수 본문과 동일함
    	// ... 
    })(); // **함수 표현식 즉시 호출! 이어지는 6.2.1 에서 다룹니다.**
    
    factorial(6);
    // 720
    
    factorial(7);
    // 5040
    ```
    
    - 위와 같이 표현식으로 `hideTheCache` 함수를 정의하면 외부/전역 스코프가 아닌 자체 스코프에 존재하게 되므로 겹칠 일도 없이 문제를 해결하였다.
    - 이름을 완전히 생략하고 익명 함수 표현식으로 정의할 수도 있긴 합니다.(하지만 뭔가 단점이나, 고려해야 할 부분이 있는듯.. 부록 A.2절에서 소개될 예정)

### 6.2.1 함수 표현식 즉시 호출하기
(IIFE 패턴, Immediately invoked function expression, 즉시 실행 함수 표현식)

- 이전 예제 중 [**기명 함수 표현식을 쓴 예제에서](https://www.notion.so/CHAPTER-6-151c7bdaffa480629f56eb0d1b9a8a9c?pvs=21)** function 표현식 전체를 ()로 감싸고, 마지막 두 부분에 두 번째 () 를 추가했습니다. (첫 번째 ()는 필수가 아니지만 가독성을 위해 추가했습니다.)
- 이런 방식을 `IIFE 패턴` 이라고 합니다.
- IIFE 는 기명/익명 모두 가능합니다(익명이 훨씬 흔합니다).
- 이 함수는 독립적일 수도 있고, 다른 구문의 일부가 될 수도 있습니다.
- hideTheCache()는 factorial()함수 참조를 반환하고, 이 참조는 =으로 factorial 변수에 할당됩니다.(예제 참고)
- 독립형 IIFE
    - 예시 코드:
    
    ```jsx
    // 외부 스코프
    
    (function(){ // 독립형 IIFE에서는 첫 번째 ()가 옵션이 아니라 필수이다.
    	// 내부에 숨겨진 스코프
    })();
    ```
    

### 함수의 경계

- 스코프를 정의할 목적으로 IIFE를 사용하면 주변 코드에 따라 의도하지 않은 결과가 발생할 수 있으므로 **주의해야한다.**
- 그 이유는, IIFE도 온전한 함수이기 때문에 **IIFE를 사용하면 함수 경계가 변경되는데 이는 문이나 구조의 동작을 바꿀 수 있기 때문.**
    - 코드에 `return`문이 있다고 가정했을 때, 이 코드를 IIFE가 둘러싸게 되면 return은 IIFE 함수를 참조하게 되어서 해당 코드의 반환값이 IIFE의 반환값이 되어버린다.
    - 관련 예시:
        
        1. **무의미한 반환값**
        
        IIFE가 반환하는 값을 활용하지 않으면 계산이 의미 없어집니다.
        
        ```jsx
        (function () {
          return 42; // 반환값이 사용되지 않음
        })();
        
        ```
        
        ---
        
        2. **변수를 통한 반환값 활용**
        
        IIFE의 반환값을 변수에 저장해 활용할 수 있습니다.
        
        ```jsx
        let result = (function () {
          return 42;
        })();
        console.log(result); // 출력: 42
        
        ```
        
        ---
        
        3. **스크립트 반환값 변경**
        
        IIFE가 기존의 반환값을 대체할 수 있습니다.
        
        ```jsx
        // 기존 코드
        return 100;
        
        // IIFE로 대체
        (function () {
          return 42;
        })();
        
        ```
        
        ---
        
        4. **코드 흐름 방해**
        
        IIFE의 반환값이 연산에 직접 사용되어 예상치 못한 결과를 초래할 수 있습니다.
        
        ```jsx
        let total = 10 + (function () {
          return 42;
        })();
        console.log(total); // 출력: 52
        
        ```
        
        ---
        
        5. **전역 상태 변경**
        
        IIFE 내부에서 전역 변수를 수정하여 예상치 못한 결과를 초래할 수 있습니다.
        
        ```jsx
        let x = 10;
        (function () {
          x = 42; // 전역 변수 수정
        })();
        console.log(x); // 출력: 42
        
        ```
        
        ---
        
        6. **복잡한 설정 로직**
        
        IIFE를 활용하여 값을 반환하는 경우, 코드가 복잡해질 수 있습니다.
        
        ```jsx
        let config = (function () {
          return { debug: true, version: "1.0.0" };
        })();
        console.log(config); // 출력: { debug: true, version: "1.0.0" }
        
        ```
        
        ---
        
        7. **디버깅 어려움**
        
        IIFE 내부에서 에러가 발생하면 디버깅이 어렵습니다.
        
        ```jsx
        (function () {
          return someUndefinedFunction(); // 실행 중 에러 발생
        })();
        
        ```
        
- 그리고 break나 continue 문은 IIFE 경계를 넘어서 작동하지 않으므로 이들로 함수 경계 밖의 제어문을 통제할 수 없다는 점도 주의해야 함.(e.g. `return`, `this`, `break`, `continue`)
    - 이 경우에는 함수 대신 블록을 사용해 스코프를 만드는게 좋음
