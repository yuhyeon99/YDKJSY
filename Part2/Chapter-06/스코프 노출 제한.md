> 프로그램 전체에 적용되는 결정 사항의 패턴을 알아봅시다.
어떻게 그리고 왜 함수와 블록을 사용해 프로그램 내 변수를 다양한 스코프로 구성해야 하는지를 ‘스코프 과다 노출 제한’ 관점에서 알아보겠습니다.
> 

### 6.1 최소 노출의 원칙(POLE)

- 블록 스코프가 왜 필요한걸까?
- POLE(최소 노출의 원칙)을 준수하기 위해서 필요한 개념이다.
- POLE(Principle Of Least Exposure)란?
    - POLP(Principle Of Least Privilege)을 약간 변형한 원칙이다.
        - 시스템 구성 요소에는 최소한의 권한을 부여하고 접근도 최소화하며 노출 역시 최소화해야 한다는 설계 원칙. **방어적인 아키텍처 설계를 대변**함
        - POLP를 기반으로 아키텍처를 설계해 각 구성 요소가 필요한 최소한의 기능으로 연결되면, **한 구성 요소의 손상이나 장애가 나머지 시스템에 미치는 영향이 최소화**되므로 시스템 전체 보안이 더 강력해진다는 장점이 있음.
    - POLP의 변형인 POLE은 조금 더 낮은 수준의 설계에 집중
    - POLE을 따른다고 했을 때 최소화하고 싶은 항목은 **스코프마다 등록된 변수의 노출**
- 프로그램의 모든 변수를 전역 스코프에 배치하면 안 되는 이유
    1. 이름 충돌:
        - 범용적인 이름을 가진 변수/함수를 사용하면서 전역 스코프에 2개 이상 동일하게 등록되어 있다면, 이름 충돌이 발생한다.
        - 이런 방식은 예상치 못한 방식으로 변수나 함수를 사용할 수 있어 버그가 발생할 확률이 매우 높음
        - 예) 모든 반복문에서 하나의 전역 인덱스용 변수 i를 사용한다고 가정했을 때, A라는 함수의 반복문이 B라는 함수의 반복문과 동시에 실행되는 경우, 공유된 변수 i가 예상치 못한 값으로 변경될 수 있음.
    2. 예기치 않은 작동:
        - 비공개(private) 변수/함수를 프로그램 내부에 노출하면, 다른 개발자가 의도하지 않은 방식으로 변수나 함수를 사용할 수 있음.
            - 비굥개 변수/함수를 프로그램 내부에 노출하지 못하게 하는 대표적인 방법으론 `클로저`가 있음
            
            ```jsx
            function closerEx() {
            	let count = 0;
            	
            	function increase() {
            		count ++;
            		console.log(count);
            	}
            	
            	return increase;
            }
            
            const firstCloser = closerEx();
            firstCLoser();
            ```
            
        - 예) 숫자만 관리하는 배열이 따로 있고, 숫자를 사용하고 싶을 때는 이 배열에 접근해서 숫자를 얻어온다고 가정했을 때, 이 배열에 불리언이나 문자열을 추가할 수 있다면 우리의 코드는 예기치 않게 오작동할 수 있음. 
        예2) 개인 정보를 담고 있는 변수나 함수가 노출되면 악의를 가진 이들이 우리가 설정한 제한을 우회해 도용할 수 있음
    3. 의도치 않은 종속성
        - 변수나 함수가 불필요하게 노출되면 다른 개발자가 비공개로 처리된 변수/함ㅅ ㅜ를 사용하고 여기에 의존하기까지 할 수 있음
        - 이런 행동이 당장 프로그램을 손상하지는 않지만, 향후 리팩터링 시 좋지 않음
- POLE를 준수한 코드 예시
    
    ```jsx
    function diff(x, y) {
    	if (x > y) {
    		let tmp = x; // tmp는 여기서만 필요함
    		x = y;
    		y = tmp;
    	}
    	return y - x;
    }
    ```
    
    - `diff` 함수에서 반환값`(y-x)`이 0보다 크거나 같게 하려면 `y`가 `x`보다 크거나 같아야함
    - `x`가 `y`보다 더 크면 반환값이 음수가 되므로 이를 방지하기 위해 `tmp` 변수를 사용해 `x`와 `y`를 바꿔 차를 구함
    - `tmp`가 `if` 블록 안에 있든 함수 수준에 속해 있든 중요하지 않아 보일 수 있지만, tmp는 전역 변수가 되어서는 안됨.
    - `tmp`는 POLE에 따라 스코프 내에 최대한 숨겨져 있어야 합니다.
        - 변수를 사용하는 범위를 제한하면, **해당 변수가 왜 필요한지, 어디서 사용되는지 더 명확**하게 드러납니다.
        - `tmp`가 `if` 블록 안에 있으면 **이 변수는 해당 블록 안에서만 사용된다는 의도가 명확**합니다.
    - 이렇게 `if` 블록 안에서 `let`을 사용해 `tmp`를 선언하면 `tmp`의 스코프를 블록으로 차단할 수 있습니다.

### 6.2 일반(함수) 스코프에 숨기기

- 가능한 한 가장 낮은 스코프(가장 깊은 중첩 스코프)에 변수와 함수 선언을 숨기는 함수 스코프에 관련된 내용
- 함수 스코프 지정이 유용한 경우
    - 계승(팩토리얼(!로 표기))
        - 1에서 n까지의 모든 정수를 곱하는 것.
        - 계승에서는 한 번 계산된 정수의 계승을 다시 계산할 필요가 없음
        - 이는 캐시에 저장하여 메모리를 희생하긴 하지만 대신 계산 낭비를 없애 속도를 높일 수 있음
    - **예제 코드:**
    
    ```jsx
    var cache = {};
    
    function factorial(x) {
    	if (x < 2) return 1;
    	if (!(x in cache)) { // 캐시 객체 안에 계산한 정수의 계승이 있는지 확인
    		cache[x] = x * factorial(x - 1);
    	}
    	return cache[x];
    }
    
    factorial(6);
    // 호출 스택에 쌓이는 순서: 1 2 3 4 5 6
    // 호출 스택에서 실행되는 순서: 6 5 4 3 2 1
    // 1. cache[6] = 6 * factorial(5); => 6 * 120 = 720 최종 값 
    // 2. cache[5] = 5 * factorial(4); => 5 * 24 = 120
    // 3. cache[4] = 4 * factorial(3); => 4 * 6 = 24
    // 4. cache[3] = 3 * factorial(2); => 3 * 2 = 6
    // 5. cache[2] = 2 * factorial(1); => 2 * 1 = 2
    // 6. return 1;
    
    factorial(7)
    // 5040, 재귀함수 한번 호출한 후 cache[6]를 바로 반환받아서
    // 7 * 720 = 5040 으로 계산 낭비를 없앰
    ```
    
    - 여기서 주목해야 할 점은 cache 변수는 `factorial()`의 작동 방식을 나타내는 비공개 변수라는 점.
        - 외부 스코프, 특히 전역 스코프에 있는 변수가 아니므로 노출되면 안 되는 비밀스러운 변수
    - 그런데 `cache` 변수를 `factorial()` 함수 내부로 숨기는 것으로는 문제를 해결할 수 없음
        - `cache` 변수는 호출이 여러 번 일어나는 경우에도 유지되어야 하므로 함수 외부 스코프에 있어야 하기 때문.
    - **해결책:**
        
        > 외부/전역 스코프와 내부 `factorial()` 사이에 `cache` 가 위치할 중간 스코프를 정의하면 됩니다.(클로저)
        > 
        
        ```jsx
        // 외부/전역 스코프
        
        function hideTheCache() {
        	// cache를 숨길 중간 스코프
        	var cache = {};
        	
        	return factorial;
        	// ************************
        	
        	function factorial(x) {
        		// inner scope
        		if (x < 2) return 1;
        		if (!(x in cache)) { // 캐시 객체 안에 계산한 정수의 계승이 있는지 확인
        			cache[x] = x * factorial(x - 1);
        		}
        		return cache[x];
        	}
        }
        
        var factorial = hideTheCache(); // 인스턴스 생성
        
        factorial(6);
        // 720
        
        factorial(7);
        // 5040
        ```
        
    - `hideTheCache()` 함수는 `factorial()`을 여러 번 호출하는 동안 `cache`를 지속시킬 스코프를 만드는 것 외에는 용도가 없습니다.
    - `factorial()`이 `cache`에 접근할 수 있게 하려면 동일한 스코프에 `factorial()`을 정의해야 함.
    - 그 다음 `hideTheCache()`에서 `factorial` 함수를 반환하도록 하고 이 함수 참조를 외부 스코프인 `factorial` 변수에 저장합니다.(=클로저)
    - 변수나 함수를 숨겨야 하는 상황이 생기면(`hideTheCache`함수를 숨기고 싶을 때) 특이한 이름을 가진 함수를 정의하는 것보다 함수 표현식을 사용하는  게 더 나은 해결책이 될 수 있습니다.
    
    ```jsx
    var factorial = (function hideTheCache() {
    	// 위 예제의 hideTheCache 함수 본문과 동일함
    	// ... 
    })(); // **함수 표현식 즉시 호출! 이어지는 6.2.1 에서 다룹니다.**
    
    factorial(6);
    // 720
    
    factorial(7);
    // 5040
    ```
    
    - 위와 같이 표현식으로 `hideTheCache` 함수를 정의하면 외부/전역 스코프가 아닌 자체 스코프에 존재하게 되므로 겹칠 일도 없이 문제를 해결하였다.
    - 이름을 완전히 생략하고 익명 함수 표현식으로 정의할 수도 있긴 합니다.(하지만 뭔가 단점이나, 고려해야 할 부분이 있는듯.. 부록 A.2절에서 소개될 예정)

### 6.2.1 함수 표현식 즉시 호출하기
(IIFE 패턴, Immediately invoked function expression, 즉시 실행 함수 표현식)

- 이전 예제 중 [**기명 함수 표현식을 쓴 예제에서](https://www.notion.so/CHAPTER-6-151c7bdaffa480629f56eb0d1b9a8a9c?pvs=21)** function 표현식 전체를 ()로 감싸고, 마지막 두 부분에 두 번째 () 를 추가했습니다. (첫 번째 ()는 필수가 아니지만 가독성을 위해 추가했습니다.)
- 이런 방식을 `IIFE 패턴` 이라고 합니다.
- IIFE 는 기명/익명 모두 가능합니다(익명이 훨씬 흔합니다).
- 이 함수는 독립적일 수도 있고, 다른 구문의 일부가 될 수도 있습니다.
- hideTheCache()는 factorial()함수 참조를 반환하고, 이 참조는 =으로 factorial 변수에 할당됩니다.(예제 참고)
- 독립형 IIFE
    - 예시 코드:
    
    ```jsx
    // 외부 스코프
    
    (function(){ // 독립형 IIFE에서는 첫 번째 ()가 옵션이 아니라 필수이다.
    	// 내부에 숨겨진 스코프
    })();
    ```
    

### 함수의 경계

- 스코프를 정의할 목적으로 IIFE를 사용하면 주변 코드에 따라 의도하지 않은 결과가 발생할 수 있으므로 **주의해야한다.**
- 그 이유는, IIFE도 온전한 함수이기 때문에 **IIFE를 사용하면 함수 경계가 변경되는데 이는 문이나 구조의 동작을 바꿀 수 있기 때문.**
    - 코드에 `return`문이 있다고 가정했을 때, 이 코드를 IIFE가 둘러싸게 되면 return은 IIFE 함수를 참조하게 되어서 해당 코드의 반환값이 IIFE의 반환값이 되어버린다.
    - 관련 예시:
        
        1. **무의미한 반환값**
        
        IIFE가 반환하는 값을 활용하지 않으면 계산이 의미 없어집니다.
        
        ```jsx
        (function () {
          return 42; // 반환값이 사용되지 않음
        })();
        
        ```
        
        ---
        
        2. **변수를 통한 반환값 활용**
        
        IIFE의 반환값을 변수에 저장해 활용할 수 있습니다.
        
        ```jsx
        let result = (function () {
          return 42;
        })();
        console.log(result); // 출력: 42
        
        ```
        
        ---
        
        3. **스크립트 반환값 변경**
        
        IIFE가 기존의 반환값을 대체할 수 있습니다.
        
        ```jsx
        // 기존 코드
        return 100;
        
        // IIFE로 대체
        (function () {
          return 42;
        })();
        
        ```
        
        ---
        
        4. **코드 흐름 방해**
        
        IIFE의 반환값이 연산에 직접 사용되어 예상치 못한 결과를 초래할 수 있습니다.
        
        ```jsx
        let total = 10 + (function () {
          return 42;
        })();
        console.log(total); // 출력: 52
        
        ```
        
        ---
        
        5. **전역 상태 변경**
        
        IIFE 내부에서 전역 변수를 수정하여 예상치 못한 결과를 초래할 수 있습니다.
        
        ```jsx
        let x = 10;
        (function () {
          x = 42; // 전역 변수 수정
        })();
        console.log(x); // 출력: 42
        
        ```
        
        ---
        
        6. **복잡한 설정 로직**
        
        IIFE를 활용하여 값을 반환하는 경우, 코드가 복잡해질 수 있습니다.
        
        ```jsx
        let config = (function () {
          return { debug: true, version: "1.0.0" };
        })();
        console.log(config); // 출력: { debug: true, version: "1.0.0" }
        
        ```
        
        ---
        
        7. **디버깅 어려움**
        
        IIFE 내부에서 에러가 발생하면 디버깅이 어렵습니다.
        
        ```jsx
        (function () {
          return someUndefinedFunction(); // 실행 중 에러 발생
        })();
        
        ```
        
- 그리고 break나 continue 문은 IIFE 경계를 넘어서 작동하지 않으므로 이들로 함수 경계 밖의 제어문을 통제할 수 없다는 점도 주의해야 함.(e.g. `return`, `this`, `break`, `continue`)
    - 이 경우에는 함수 대신 블록을 사용해 스코프를 만드는게 좋음

### 6.3 블록으로 스코프 지정

- 블록은 `let`이나 `const`같은 블록 스코프 선언을 포함해야 할 필요가 있을 때만 스코프로 작용합니다.
    - 예시 코드:
    
    ```jsx
    {
    	// 아직 스코프가 필요하지 않습니다.
    	
    	// ...
    	
    	// 이제 블록 스코프여야 한다는 것을 인지했습니다.
    	let thisIsNowAScope = true;
    	
    	for(let i = 0; i < 5; i ++) {
    		// 여기도 스코프인데
    		// 이터레이션마다 각각 활성화됩니다.
    		if(i % 2 == 0) {
    			// 여기는 스코프가 아닌 블록일 뿐입니다.
    			console.log(i);
    		}
    	}
    }
    
    // 0 2 4
    ```
    
    - 중괄호 쌍이 항상 블록 스코프를 생성하는 건 아닙니다.
    - 객체 리터럴은 {}를 사용해 키-값 목록을 구분하지만, 이러한 객체값이 스코프는 아닙니다.
    - class는 {}를 사용해 본문을 정의하는데, 이는 블록이나 스코프가 아닙니다.
    - function은 본문을 감쌀 때 {}를 사용하는데, 엄밀히 말해 이는 블록이 아니라 함수 본문을 나타내는 단일 문이므로 블록 스코프를 형성하지 않습니다. 이때 중괄호는 함수 스코프를 생성합니다.
    - case 절 주변의 switch 구문에 사용된 {}로는 블록이나 스코프를 정의할 수 없습니다.
- 명시적으로 블록을 만드는 게 의미적인 신호가 될 순 있지만 블록 내부에 선언이 없다면 중괄호 쌍은 스코프를 만들지 않고 실행 동작에도 영향을 끼치지 않습니다.
- 블록 스코프를 지원하는 대부분의 프로그래밍 언어에서 명시적으로 블록 스코프를 만드는건 변수의 범위를 좁히는 일반적인 패턴입니다.
- 저자도 POLE에 따라 JS에서도 이런 패턴이 보편화되어야 한다고 생각함.
- 식별자가 노출될 수 있는 범위를 최소한으로 줄이려면 (명시적) 블록 스코프를 사용하세요.
    - 예시 코드:
    
    ```jsx
    if (somethingHappened) {
    	// 이것은 블록이지만 스코프는 아님(let이나 const가 없기 때문)
    	
    	{
    		// 이것은 블록이면서 명시적 (블록) 스코프입니다.
    		let msg = somethingHappened.message(); // 변수 msg를 현재 블록 스코프로 제한
    		notifyOthers(msg);
    	}
    	
    	// ....
    	recoverFromSomething();
    }
    ```
    
    - 여기서 if 문 내부의 {} 중괄호는 작은 명시적인 내부 블록 스코프를 나타내며, msg 변수는 전체 if 블록에서 필요하지 않기 때문에 해당 블록 스코프로 제한했습니다.
    - 저자는 POLE 원칙을 사용할 때 합리적인 사고가 이루어졌다는 전제 하에 각 변수에 대해 가장 작은 블록을 정의하는 것이 좋다고 생각한다.
    - 실질적인 코드 예시:
    
    ```jsx
    function sortNamesByLength(names) {
    	var buckets = [];
    	
    	for (let firstName of names) { // 이름 길이 순으로 요소들을 구분하기 위한 반복문
    		if (buckets[firstName.length] == null) {
    			buckets[firstName.length] = [];
    		}
    		buckets[firstName.length].push(firstName);
    	}
    	
    	// 스코프를 좁히는 블록
    	{
    		let sortedNames = [];
    		
    		for (let bucket of buckets) {
    			if(bucket) {
    				// 각 bucket을 알파뱃순으로 정렬
    				bucket.sort();
    				
    				// 정렬된 이름을 실행 목록에 추가
    				sortedNames = [
    					...sortedNames, // 앞서 정렬한 요소들 유지
    					...bucket // 새롭게 정렬된 이름 추가
    				];
    			}
    		}
    		
    		return sortedNames; // 최종 정렬된 요소들 반환
    	}
    }
    ```
    
    - 총 다섯 개의 스코프에 여섯 개의 식별자가 선언
    - 변수 모두를 하나의 외부/전역 스코프에 선언하는게 불가능하지는 않으나, 모든 변수를 하나의 스코프에 선언하면 코드 구조가 혼란스러워지고, 향후 버그 유발 가능성이 커짐
    - 그래서 예시에서는 변수를 각각의 내부 중첩 스코프에 적절하게 분할
    - sortedNames 은 함수 스코프 시작부분에서 선언할 수 있지만 이 변수는 함수 뒷부분에서 필요하다.
    따라서 **변수가 상위 레벨 스코프에 과도하게 노출되지 않도록 POLE에 따라 내부 명시적 블록 스코프에서 선언하였음.**

### 6.3.1 var와 let

- [**앞선 예시**](https://www.notion.so/CHAPTER-6-151c7bdaffa480629f56eb0d1b9a8a9c?pvs=21)의 var buckets 선언에 관련된 이야기.
- `buckets`변수를 선언할 때 `let` 대신 `var`를 사용했다
    - ‘이 변수는 함수 스코프’라는 신호를 명확하게 전달할 수 있기 때문

### 6.3.2 let의 위치

- `let` 키워드를 언제 적절하게 사용해야 하는가?
- POLE을 따르면 그 답을 얻을 수 있음.
- 조금 더 명시적으로 `let` 의 위치에 관해 설명하자면
    - 선언 키워드는 의사 결정에 영향을 미치지 않습니다.
    - 가장 좋은 방법은 스스로 ‘이 변수를 최소한으로 노출시키면서 요구 사항을 충족하는 스코프는 어디인가?’ 라는 질문을 해보는 것
- 선언이 블록 스코프에 속해 있다면 let을 사용하고, 함수 스코프에 있다면 var을 사용하라**(저자의 의견)**
- ES6 이전에는 let이 없었으므로 사실상 블록 스코프를 사용할 수 없었음.
- let을 사용해야만 하는 예시
    
    ```jsx
    for (var i = 0; i < 5; i++) {
    	// 무언가를 하는 코드
    }
    
    **// for 반복문에서는 반복문이 어디에 정의되었든지 상관없이 기본적으로
    // i는 항상 반복문 안에서만 사용해야 함. 그렇기 때문에 POLE에 따라
    // var 대신 let으로 i를 선언해야 합니다.**
    
    for (let i = 0; i < 5; i++) {
    	// 무언가를 하는 코드
    }
    
    **// var를 let으로 전환할 때 코드가 '중단'되는 거의 유일한 경우**
    
    for (var i = 0; i < 5; i++) {
    	if (checkValue(i)) {
    		break;
    	}
    }
    
    if (i < 5) {
    	console.log("루프가 일찍 멈췄습니다!");
    }
    
    **// 이런 패턴이 드물진 않지만 이렇게 코드를 작성하면 구조에 대한 지적을 받을 수 있으므로,
    // 목적을 달성하려면 다른 외부 스코프를 사용하는게 낫다.**
    
    var lastI; // i 상태 추적 변수
    
    for (var i = 0; i < 5; i++) {
    	lastI = i;
    	if (checkValue(i)) {
    		break;
    	}
    }
    
    if (lastI < 5) {
    	console.log("루프가 일찍 멈췄습니다!");
    }
    ```
    

### 6.3.3 catch와 스코프

- ES3에 `try…catch`가 도입된 이후, catch 절에서 선언된 변수는 catch 절 밖에서는 사용할 수 없었습니다. ⇒ catch 절에서 (let과 const 및 매개변수로)선언한 변수는 해당 블록으로 블록 스코프가 지정됨.
+ 하지만 var 선언은 여전히 외부 함수/글로벌 스코프에 연결됨.
- ES2019 이전에는 catch 절에서 오류 객체를 사용하려면 catch 뒤에 매개변수를 반드시 추가했어야 했는데 ES2019에서는 선택 사항으로 바뀌었음.
    - 그런데 catch 블록을 오류 객체 변수 선언 없이 사용하면 `catch`블록은 스코프를 형성하지 않고 그냥 블록으로 처리됨
    - **실제로 어떤 영향을 미칠까?**
        
        ### 스코프 충돌 예제:
        
        ```jsx
        let error = "Global error";
        
        try {
          throw new Error("Something went wrong!");
        } catch { // 오류 객체를 선언하지 않음
          error = "Handled error"; // 전역 변수 error를 덮어씀
        }
        
        console.log(error); // 출력: "Handled error"
        
        ```
        
        ### 스코프 분리 예제:
        
        ```jsx
        let error = "Global error";
        
        try {
          throw new Error("Something went wrong!");
        } catch (err) { // 오류 객체를 선언함
          let error = "Handled error"; // 새로운 스코프에서 별도의 error 선언
          console.log(error); // 출력: "Handled error"
        }
        
        console.log(error); // 출력: "Global error"
        
        ```
        
    - catch에서 오류 객체 변수를 생략하는 패턴은 작은 변화지만 **많이 쓰이는 효율적인 단순화 패턴입니다. 이 패턴을 사용하면 불필요한 스코프를 줄여서 약간의 성능 향상을 꾀할 수도 있음.**

### 6.4 블록 내 함수 선언

- 블록 내 함수 선언(function declarations in blocks, FiB) 이란?
- 함수 선언을 var 선언과 동일하다고 생각하는 사람들이 많습니다. 그럼 함수 선언도 var 변수와 같은 스코프 메커니즘을 따를까요?
    - 맞기도 하고, 아니기도 합니다. 혼란스러우니 코드를 보며 이해해봅시다.
    
    ```jsx
    if (false) {
    	function ask() {
    		console.log("여기가 실행될까요?");
    	}
    }
    ask();
    ```
    
    - 이 프로그램을 실행했을 때 기대할 수 있는 결과
        1. `ask` 식별자의 스코프가 `if` 블록 스코프로 지정되어 외부/전역 스코프에서는 사용할 수 없어 `ask()` 호출 시 `ReferenceError` 예외와 함께 호출에 실패
        2. `ask` 식별자가 존재하긴 하지만 `if` 구문이 실행되지 않아 정의가 이뤄지지 않았기 때문에 `ask`는 호출 가능한 함수가 아니어서 호출 시 `TypeError`와 함께 호출 실패 **(내 예상)**
        3. 문제없이 호출되어 ‘여기가 실행될까요?’ 출력
    - 코드를 어떤 JS 환경에서 실행하는지에 따라 결과가 달라진다(?) 예측하기 힘듦..
    - 블록 내부에 함수 선언을 하면 블록 스코프가 적용되어 1번 처럼 작동해야함.**(Reference Error 예외가 표시되어야 한다)**
    - 하지만 브라우저 기반 JS 엔진 대부분이(V8 엔진을 사용하는 `Node.js`도 포함) 2번처럼 작동합니다.
    - 식별자는 `if` 블록 외부 스코프로 지정되지만 함숫값이 자동으로 초기화되지 않아 `undefined` 상태로 남기 때문.
- 위와 같이 브라우저에서 돌아가는 JS 엔진들이 명세서에 반하는 작동을 하는 이유
    - ES6에서 블록 스코프가 도입되기 전에 이미 이러한 엔진들은 FiB와 관련된 동작을 지원하고 있었다.
    - ES6 이후 명세서를 준수하기 위해 엔진 동작을 변경하며 기존 웹사이트에서 돌아가는 JS 코드에 문제가 발생할 수 있다는 우려가 있었기 때문.
- 블록 안에 function을 선언하는 가장 일반적인 사례는 if…else 문에서처럼 환경에 따라 함수를 조건부로 정의하는 경우입니다.
    - 예시 코드:
    
    ```jsx
    // FiB (블록 내 함수 선언, function declarations in blocks) 예제 
    if (typeof Array.isArray != "undefined") {
    	function isArray(a) {
    		return Array.isArray(a);
    	}
    }
    else {
    	function isArray(a) {
    		return Object.prototype.toString.call(a) == "[object Array]";
    	}
    }
    ```
    
    - `isArray()`를 하나만 정의하고 그 안에 `if`구문을 넣으면 함수를 호출할 때마다 조건을 검사하지 않아도 typeof Array.isArray를 한 번만 체크하면 되기 때문에 이렇게 코드를 작성하고 싶다는 유혹에 빠질 수 있다. (개인적인 생각으로는 저 방식이 나름 합리적인 듯 하지만.. 효율에 비해 유지보수의 난이도가 더 높아지는 것 같다..)
- FiB의 두 번째 사례
    
    ```jsx
    if (true) {
    	function ask() {
    		console.log("제가 호출되었나요");
    	}
    }
    
    if (true) {
    	function ask() {
    		console.log("아니면 저일까요?");
    	}
    }
    
    for (let i = 0; i < 5; i++) {
    	function ask() {
    		console.log("아니면 설마 저일까요?");
    	}
    }
    
    ask();
    
    function ask() {
    	console.log("잠깐만요, 설마 저를 호출한 걸까요?");
    }
    ```
    
    - 마지막 ask()가 ask(); 위쪽으로 호이스팅될 거라 예상할 수 있음
    - 하지만 이 예상은 틀렸음(왜 틀렸는지는 설명하지 않음. 쓸모없는 상식에 불과하다고 함)
- **위 두 예시들처럼 FiB는 변덕스러우니 FiB를 완전히 피해야 실용적으로 코드를 작성할 수 있음**
- 성능은 약간 떨어질 수 있어도 앞선 if…else 예시는 하나의 함수 정의 안에서 if…else 로 로직을 조건부로 실행하도록 수정하길 바람..

### 6.5 정리

- 렉시컬 스코프 규칙의 핵심은 우리가 렉시컬 스코프 규칙에 맞게 코드를 작성하면 **프로그램의  변수를 운영 목적과 의미에 맞게 체계화 할 수 있음.**
- 변수를 정리하는 데 있어서 가장 중요한 것은 **변수를 불필요한 범위에 과도하게 노출되지 않도록 하는 것(POLE) 입니다.**
- 다음 장 부터는 ‘클로저’에 대해 이야기하겠습니다.

### CHAPTER 6. 스코프 노출 제한 문제

[CHAPTER 6. 스코프 노출 제한 문제](https://www.notion.so/CHAPTER-6-159c7bdaffa480279978e28ecd6533a9?pvs=21)
