### 2.1 구슬과 양동이(글 내용을 간단하게 요약)

- 구슬은 프로그램 내 변수나 식별자를 의미하고, 양동이(함수 혹은 블록)는 스코프를 나타냅니다.
- 구슬과 양동이는 각각 색을 가지고 있으며, 구슬의 색은 그 구슬이 선언된 양동이(스코프)의 색을 따릅니다.
- 스코프 예제
    - 스코프 버블은 컴파일 중에 함수/블록 스코프의 위치에 따라 결정됩니다.
    - 스코프는 서로 중첩이 가능합니다.
    - 각 **구슬(변수나 식별자)**은 어떤 **버블(스코프)에서 정의되었느냐에 따라 색이 결정**됩니다.
    - 선언된 **변수나 식별자를 참조할 땐** 아래 두 조건 속에 정의되어 있어야 합니다.
        1. 현재 스코프
        2. 바깥 스코프(= 현재 스코프의 위)
    - 런타임 중에서 선언이 아닌 **비선언(= 참조)**
        
        ![image](https://github.com/user-attachments/assets/a07a68b5-35c3-4ada-938c-48ed491542d9)

        
    1. `for` 반복문에서 **`students`** 는 **선언이 아닌 참조**이기 때문에 파란색 양동이 스코프에서 students인 구슬을 찾습니다. ⇒ 없음.
    2. 다음 바깥/위 스코프인 빨간색 양동이로 영역을 확장(= 스코프 체이닝)해 원하는 구슬을 찾습니다. ⇒ 찾음 : `var students`
    3. `studentID` 또한 1,2 번과 동일한 방식으로 `매개변수 **studentID`를 참조**

### 2.2 JS 엔진 구성원 간의 대화

- 이 장에선 스코프가 어떻게 작동하는지 기초를 다지기 위해 JS 엔진 내부 구성 요소들을 의인화 하여 설명한다.
    - **엔진**: 컴파일레이션을 시작부터 끝까지 책임지고 JS로 만든 프로그램을 실행함
    - **컴파일러**: 파싱과 코드 생성 과정에서 일어나는 모든 잡일을 담당함.
    - **스코프 매니저**: 선언된 모든 변수와 식별자를 담은 탐색용 목록을 작성하고 유지보수함.
    여기에 더해 코드 실행 시, 선언된 변수와 식별자 접근 관련 규칙을 강제함.
    - 예시 코드:
    
    ```jsx
    var students = [
    	{ id: 14, name: "폴"},
    	{ id: 73, name: "슉"},
    	{ id: 112, name: "은도"},
    	{ id: 6, name: "호두집사"},
    	{ id: 15, name: "망푸"},
    ];
    
    function getStudentName(studentID) {
    	for (let student of students) {
    		if (student.id == studentID) {
    			return student.name;
    		}
    	}
    }
    
    var nextStudent = getStudentName(73);
    
    console.log(nextStudent);
    // 슉
    ```
    
    - 컴파일러가 `var students = [ … ]`에서  거치는 과정
        - 요약: 
        1. 컴파일러가 변수를 선언할 때, 스코프 매니저에게 해당 변수가 이미 선언된 적이 있는지 묻습니다.
        2. 그에 따라 변수를 새로 선언하거나 기존 선언을 유지합니다. 
        3. 또한, 컴파일러는 프로그램 실행 시점에 필요한 할당문 코드를 생성합니다. 
        4. 이후, 실행 시점에 엔진은 스코프 매니저를 통해 변수를 찾고(필요할 경우 스코프 체이닝을 통해 상위 스코프에서 변수를 탐색한 후) 값을 할당합니다.
    - 컴파일레이션 첫 단계에서 일어나는 일
        - 요약: 컴파일러는 함수나 블록 스코프를 만나서 실행할 때 스코프 매니저가 새로운 스코프를 위한 양동이를 만들고 이를 인스턴스화하게끔 신호를 보냅니다.
    - 엔진과 스코프 매니저 간에 대화(두 번째 단계)
        - 요약: 엔진이 변수와 함수가 선언되어 있는지 확인하고, 그 값을 초기화하거나 실행하기 위한 준비를 하는 과정

### 2.3 중첩 스코프

- 함수 `getStudentName(73)`을 실행할 때가 되면 엔진은 함수 스코프 인스턴스를 만들어달라고 스코프 매니저에게 부탁합니다. ⇒ 스코프 매니저는 인수 73을 할당할 매개변수 studentID를 찾는 일을 이어서 수행합니다.
- `getStudentName()` 용 함수 스코프는 전역 스코프 안에 중첩되어 있습니다.(for 반복문 또한 마찬가지)
- 모든 스코프는 실행될 때마다 스코프에 해당하는 스코프 매니저 인스턴스를 갖게 됩니다.
+ 자동으로 해당 스코프 내 모든 식별자(구슬)가 스코프(양동이)에 등록됩니다.
- for 반복문에 사용되는 students 변수 참조 코드는 함수 스코프 내부에 있지만, 함수 스코프에는 students 선언이 없다. ⇒ 이럴 경우 엔진은 상위 스코프인 (전역) 스코프 매니저에게 선언된 변수를 물어보고 변수 참조에 할당한다.
    
    ![image](https://github.com/user-attachments/assets/388efea9-f3a4-42e2-9f4c-f18910fe1e5c)

    

### 2.3.1 탐색이 실패할 경우

- 엔진이 상위 스코프로 탐색 범위를 확장해가며 모든 렉시컬 스코프를 뒤졌는데도 원하는 식별자를 찾지 못하면 오류가 발생한다.
- 프로그램의 모드(엄격/비엄격)에 따라 오류가 다르게 처리됩니다.
    - 자바스크립트에서 변수가 **값을 읽을 때**(소스 역할)나 **값을 할당받을 때**(타깃 역할) **선언되어 있지 않으면** `ReferenceError`가 발생합니다. 특히, **엄격 모드**에서는 값을 할당하려고 할 때 선언되지 않은 변수를 사용해도 같은 오류가 발생하게 됩니다.
    - 비엄격 모드에서는 선언되지 않은 변수에 값을 할당할 때, **오류가 발생하지 않고 자동으로 전역 변수로 선언**됩니다.
- 오류 메세지에 포함되는 not defined 는 undefined와 뜻이 유사하여 혼란을 야기하고있음
- 더욱이 typeof 연산자는 선언되지 않는 변수를 넘겼을 때 똑같이 undefined를 반환하여 혼란스러움 가중
- 우발적으로 등장하는 전역 변수에 절대 의존하면 안됨. ⇒ 항상 엄격 모드에서 작업하고 변수는 반드시 선언 후에 사용할 것

### 2.3.2 스코프 건물

- 중첩 스코프는 건물에 비유할 수 있다.
- 타깃 혹은 소스 역할을 하는 변수 참조를 찾을 때는 가장 아래 층(1층) 부터 둘러 보고 찾지 못하면 계속해서 다음 층(바깥 스코프)로 가서 변수 참조를 찾습니다.
- 찾다가 꼭대기 층(전역 스코프)에 도달하면 원하는 변수 참조 발견 여부와 상관없이 탐색이 중단됩니다.

[CHAPTER 2. 렉시컬 스코프 문제](https://www.notion.so/CHAPTER-2-121c7bdaffa48007b6f0d7de31a79dcf?pvs=21)
