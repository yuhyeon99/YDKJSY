> 클로저는 프로그래밍에서 가장 중요한 언어 특성입니다.
클로저는 함수형 프로그래밍, 모듈, 심지어는 클래스 지향 설계를 비롯한 주요 프로그래밍 패러다음의 근간을 이룹니다.
JS를 마스터하고 중요한 디자인 패턴을 코드 전반에 걸쳐 효과적으로 활용하려면 클로저에 익숙해지는게 중요합니다.
> 

### 7.1 클로저 관찰하기

- **클로저**는 **함수에서만 일어나는 함수의 동작**입니다.
    - 함수를 다루지 않는다면 클로저는 적용되지 않음
    - 객체는 클로저를 가질 수 없고 클래스도 클로저를 가질 수 없음
- 클로저를 관찰하려면 함수를 반드시 호출해야 함
- 코드 예시
    
    ```jsx
    // 외부/전역 스코프: 1. 빨간색 버블
    
    function lookupStudent(studentID) {
    	// 함수 스코프: 2. 파란색 버블
    	var students = [
    		{ id: 14, name: "paul" },
    		{ id: 73, name: "슉" },
    		{ id: 112, name: "지수" },
    		{ id: 6, name: "호진" }
    	];
    	
    	return function greetStudent(greeting) {
    		// 함수 스코프: 3. 초록색 버블
    		
    		var student = students.find(
    			student => student.id == studentID
    		);
    		
    		return `${greeting}, ${student} 님!`;
    	}
    }
    
    var chosenStudents = [
    	lookupStudent(6), // -(1)
    	lookupStudent(112) // -(1)
    ];
    
    // 함수 이름에 접근
    chosenStudent[0].name; // -(2)
    // greetStudent
    
    chosenStudents[0]("안녕하세요");
    // 안녕하세요, paul 님!
    
    chosenStudents[1]("잘 지내시죠");
    // 잘 지내시죠, 슉 님!
    ```
    
    - (1) - `lookupStudent()`가 두 번 호출되면 내부 함수 `greetStudent()`가 **두 개의 개별 인스턴스를 생성**하고, 두 인스턴스는 `chosenStudents` 배열에 저장됨
    - (2) - `lookupStudent()`함수 본문에서 실제 반환된 함수(`greetStudent`)가 배열에 잘 저장했는지를 `chosenStudents[0].name` 프로퍼티를 통해 확인했습니다.
        - `name` 프로퍼티는 자바스크립트 함수 객체의 기본 프로퍼티 중 하나로, 함수의 이름을 나타냄
    - 예시에서는 `lookupStudent()`를 두 번 호출하는데, 각 호출이 종료될 때마다 함`lookupStudent()` 함수 내부의 변수들이 가비지 컬렉션의 대상이 되어 메모리에서 사라질 거라 생각할 수 있음
        - 그러나 실제 결과는 `lookupStudent()` 함수 본문에서 반환하는 `greetStudent()` 함수가 `greeting`이라는 매개변수를 단일 인수로 받지만, 
        `greetStudent()` 함수 본문에서는 `lookupStudent()` 를 감싸는 스코프에 있는 식별자(students와 studentID)를 다수 참조하기 때문에 메모리에서 사라지지 않는다.
        - 이렇게 함수에서 반환하는 내부 함수가 외부 스코프에 있는 변수를 참조하는 것을 **클로저**라고 부른다.(`greetStudent()` 인스턴스 각각이 외부 변수인 `students`와 `studentID`를 감싸고 있다고 표현할 수 있음)
    - 만약 JS 함수에 클로저가 없었다면 `students`와 `studentID` 변수는 가비지 컬렉터의 대상이 되어 메모리에서 제거되었을 것. 이후에 `greetStudent()`함수를 호출할 땐 `ReferenceError`가 발생할 걸로 예상된다.

### 7.1.1 화살표 함수의 스코프

- 화살표 함수는 문법이 매우 간결하지만 화살표 함수에도 스코프가 존재한다.
- 예시 코드
    
    ```jsx
    var student = student.find(
    	student => 
    		// 함수 스코프: 4. 주황색 버블
    		student.id = studentID
    )
    ```
    
    - 파란색 버블(2)에 있는 `studentID`를 참조하는 코드는 `greetStudent()` 스코프에 해당하는 초록색 버블(3)이 아니고 주황색 버블(4) 스코프 안에 있는 걸 확인할 수 있음
    - 화살표 함수의 매개변수 `student`는 주황색 버블(4)에 있으므로 초록색 버블(3)에 있는 변수 `student`를 섀도잉 하는 것 역시 확인할 수 있음
        
        ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/98e7aba4-9ba3-47aa-b2a2-c247d9f7b96b/a8a9c47d-f914-4f18-b8ec-a582049a4a4c/image.png)
        

### 7.1.2 추가되는 클로저

- 클로저와 함께 자주 인용되는 대표적인 예를 살펴봅시다.
- 코드 예시
    
    ```jsx
    function adder(num1) {
    	return function addTo(num2) {
    		return num1 + num2;
    	}
    }
    
    var addTo10 = adder(10);
    var addTo42 = adder(42);
    
    addTo10(15); // 25
    addTo42(9); // 51
    ```
    
    - 인수(10, 42)와 함께 `adder()`를 호출할 때 생성되는 addTo 인스턴스는 클로저를 통해 자신만의 num1 변수를 기억함.
    - 함수 호출이 끝난 이후에도 num1은 사라지지 않음
    - addTo에 대한 클로저는 하나가 아니라 외부 함수 adder() 가 생성될 때마다 내부 함수 addTo()의 새로운 인스턴스가 생성되고, 생성된 인스턴스에는 **새로운 독립적인** 클로저가 생성됩니다.

### 7.1.3 스냅숏이 아닌 라이브 링크

- 클로저를 변수의 순간 상태를 기록한 스냅숏이라고 착각하는 경우가 많다.
- 하지만 클로저는 **실시간**으로 변수 자체에 접근할 수 있도록 **관계를 맺어주는 라이브 링크**이다.
    - 그렇기 때문에 클로저를 통해 값을 읽는 것뿐만 아니라 수정(재할당)할 수도 있다.
- 함수로 변수를 감싸서 가뒀기 때문에 프로그램에서 함수 참조가 존재하는 한 언제든 해당 변수를 읽고 쓰는 게 가능.
- 클로저로 감싼 변수를 업데이트하는 예시 코드
    
    ```jsx
    function makeCounter() {
    	var count = 0;
    	
    	return function getCurrent() {
    		count = count + 1;
    		return count;
    	};
    }
    
    var hits = makeCounter();
    
    // 내부 함수 호출이 끝나고 잠시 후
    
    hits(); // 1
    
    // 또 잠시 후
    hits(); // 2
    hits(); // 3
    ```
    
    - 변수 `count`는 내부 함수 `getCurrent()` 함수에 의해 클로저로 유지되어 가비지 컬렉션의 대상이 되지 않음
    - `hits()`함수를 호출하면 `count`에 접근해 변수를 업데이트하게 되므로 함수를 호출할 때마다 반환값이 1씩 증가

### 클로저의 외부 스코프는 반드시 함수 스코프일 필요는 없음

- 내부 함수를 감싸는 외부 스코프가 존재하기만 해도 클로저가 됨
- 예시 코드
    
    ```jsx
    var hits;
    { // 외부 스코프(함수는 아님, 블록 스코프)
    	let count = 0;
    	hits = function getCurrent() {
    		count = count + 1;
    		return count;
    	};
    }
    
    hits(); // 1
    hits(); // 2
    hits(); // 3
    ```
    

### 클로저는 “변수”가 아닌 “값”과 연관되어 있는 개념이라고 착각하면 안됨

- 이런 경우 클로저를 사용하면 특정 시점의 값을 보존할 수 있다고 착각하게 되는데, 이는 원치 않는 작동을 유발함
- 코드 예시
    
    ```jsx
    var studentName = "보라";
    
    var greeting = function hello() {
    	// "보라"가 아닌 studentName이 보존됩니다.
    	console.log(
    			`안녕하세요, ${ studentName } 님!`
    	);
    }
    
    // 함수 선언 후
    
    studentName = "지수";
    
    // 클로저로 보존된 변수에 값 재할당 후
    
    greeting();
    // 안녕하세요, 지수님!
    ```
    
    - `studentName`에 **“보라”**가 저장되어 있을 때 (**”지수”**를 재할당하기 전), `greeting()`(즉, `hello()`)을 정의하면, 클로저가 **“보라”**라는 정보를 보존하고 있을 거라 잘못 생각하는 경우가 많음.
    - 하지만 `greeting()`은 값이 아닌 `studentName`이라는 변수를 감싸고 있으므로
    `greeting()`을 호출할 때 변수의 현잿값인 **“지수”**가 출력됨
    - 정의할 때 클로저가 보존하는건 **변수**이지 **값**이 아니라는 뜻. + 위 변수는 캡슐화 되어있지 않음
- **반복문 안에 함수를 정의하는 것도 이런 오해에서 비롯한 대표적 실수입니다.**
    - 코드 예시
        
        ```jsx
        	var keeps = [];
        
        for (var i = 0; i < 3; i++) {
        	keeps[i] = function keepI(){
        		// i를 감쌈
        		return i;
        	};
        }
        
        keeps[0](); // 3 <- 예상과는 다른 결과가 나왔네요! 왜일까요?
        keeps[1](); // 3 
        keeps[2](); // 3
        ```
        
        - 대부분의 사람들은 keeps[0]()을 호출하면 keeps[0]은 반복문의 i가 0일 때, 즉 첫 번째 이터레이션에서 생성된 함수이기 때문에 0이 반환될 것이라 예상함.
        - for 문의 구조상 각 이터레이션마다 새로운 변수 i가 생긴다고 생각하기 쉽지만, 이 프로그램에서는 i를 var로 선언했기 때문에 i가 하나만 존재
            - i가 루프 블록 안에만 제한되는 것이 아니라, 루프가 실행되는 함수 전체에 공유됨.
            - 그로 인해 i는 최종적으로 3이 되고, 이후에 호출하는 keeps[0], keeps[1], keeps[2]에 저장된 각 `keepI`함수 인스턴스들은 i에 접근해서 3을 반환하게 된다.
- **그렇다면 어떻게 코드를 수정해야 원하는 대로 0, 1, 2가 출력되게 할 수 있을까요?**
    - 코드 예시
        
        ```jsx
        var keeps = [];
        
        for (var i = 0; i < 3; i ++) {
        	// 각 이터레이션마다 현재 `i`의 값을 복사해 블록 스코프에 새로운 `j`를 만듭니다.
        	let j = i;
        	
        	// 여기서 i는 함수 내에서 클로저로 사용되지 않았기 때문에
        	// 반복 당시 i의 값을 사용해도 괜찮습니다.
        	keeps[i] = function keepEachJ() {
        		// 변수 j가 클로저에 의해 참조되고 있습니다.
        		return j;
        	};
        }
        
        keeps[0](); // 0
        keeps[1](); // 1
        keeps[2](); // 2
        ```
        
        - 반복마다 생성된 함수 각각은 새로운 변수인 j에 대해 클로저를 형성함. ⇒ 각각 새로운 렉시컬 스코프(Lexical Environment)에 저장된다.
        - 반복문 내부에서 생성된 함수(`keepEachJ`)는 **현재 이터레이션의 렉시컬 환경**을 캡처합니다.
        - 비록 모든 변수가 j라는 이름을 갖고 있지만, 각 j는 반복문을 순회할 시점마다 i의 값을 복사받는다.
        - 이렇게 만들어진 j는 재할당 되지 않는다.
    - 코드 예시 2
        
        ```jsx
        var keeps = [];
        
        for (let i = 0; i < 3; i++) {
        	// `let i`는 이터레이션마다 새로운 `i`를 자동으로 제공합니다.
        	keeps[i] = function keepEachI() {
        		return i;
        	};
        }
        
        keeps[0](); // 0
        keeps[1](); // 1
        keeps[2](); // 2
        ```
        
        - for 루프에서 초깃값을 let으로 선언하면 반복 전체에 대해 변수가 하나 생성되는 게 아니라 반복마다 새로운 변수가 생성됨.

### 7.1.4 쉽게 관찰할 수 있는 클로저: Ajax와 이벤트

- 클로저는 콜백을 다룰 때 흔히 관찰할 수 있다
    
    ```jsx
    function lookupStudentRecord(studentID) {
    	ajax(
    		`https://some.api/student/${ studentID }`,
    		function onRecord(record) {
    			console.log(
    				`${ record.name } (${ studentID })`
    			);
    		}
    	)
    }
    
    lookupStudentRecord(73);
    // 보라 (73)
    ```
    
    - onRecord() 콜백 함수는 Ajax 호출로부터 응답을 받은 경우 호출되는데, 해당 호출은 ajax() 함수 내부에서 처리된다.
    - 그런데 onRecord()가 호출되는 시점은 `lookupStudentRecord()` 호출이 종료된 후 시간이 꽤 지난 후이다.
    - 이런 **비동기적 실행 환경에서**도 **콜백 함수가** studentID에 **접근할 수 있는 이유**는 바로 **클로저** 때문
- 이벤트 핸들러를 통해 클로저를 관찰할 수 있다.
    
    ```jsx
    function listenForClicks(btn, label) {
    	btn.addEventListener("click", function onClick() {
    		console.log(
    			`${ label } 버튼을 클릭했습니다!`
    		)
    	}
    }
    
    var submitBtn = document.getElementById("submit-btn");
    ```
    
    - `label`매개변수는 `onclick()`이벤트 핸들러 콜백에 의해 클로저로 둘러싸여 있다.
    - 따라서 버튼을 새롭게 클릭해도 `label`은 여전히 존재하기 때문에 같은 로그가 출력됨

### 7.1.5 보이지 않으면 어떡하죠?

> *아무도 없는 숲에서 나무 한 그루가 쓰러졌지만,
그 누구도 소리를 듣지 못했다면 소리는 난 것인가?*
> 
- 클로저를 정의할 때 **관찰 가능성**을 계속 강조했습니다. 만약 클로저가 기술적, 구현적, 학문적 관점에서는 존재하지만, 우리가 작성한 프로그램에서 클로저를 관찰할 수 없다면 어떨까요? 괜찮은 걸까요? 아닙니다.
- 이런 관점을 강조하기 위해 이번에는 클로저에 기반하지 않은 예시 몇 가지를 살펴보겠습니다.
    
    ```jsx
    function say(myName) {
    	var greeting = "안녕하세요";
    	output();
    	
    	function output() {
    		console.log(
    			`${ greeting }, ${ myName } 님!`
    		);
    	}
    }
    
    say("보라");
    // 안녕하세요, 보라 님!
    ```
    
    - 내부 함수 `output()` 은 자신을 감싸는 스코프에서 변수 greeting과 myName에 접근함
    - `output()`을 호출하는 코드가 위치한 곳은 greeting과 myName을 사용할 수 있는 동일한 스코프이기 때문에 클로저가 아닌 **렉시컬 스코프**이다.
        - `say`함수의 스코프가 종료되기 전에 `output`함수가 호출되었기 때문에 해당 스코프를 참고하는 개념이 렉시컬 스코프를 의미한다.(스코프 체인을 통해 참조하기 때문)
    
    ### 렉시컬 스코프와 렉시컬 환경의 차이
    
    - **렉시컬 스코프:** 함수가 정의된 위치를 기준으로 상위 스코프가 고정(정적 스코프)
        - `output`함수는 `say`함수 내부에서 정의 + 호출되었기 때문에, 항상 `say` 함수의 스코프를 참조
    - **렉시컬 환경:** 함수가 **실행될 때 생성되는 동적 메모리 구조**
        - 외부 함수가 실행되면서 생성된 렉시컬 환경을 클로저를 통해 참조할 수 있다.
- 전역 스코프 변수를 참조하는 경우
    - 전역 스코프 변수는 어디에서나 접근할 수 있다는 본질 때문에 관찰 가능성이라는 측면에서 클로저로 둘러싸일 필요가 없음.
    - 스코프 체인을 따라가다 보면 최종적으로는 전역 스코프와 연결되므로 어떤 함수든 스코프 체인을 따라가다 보면 최종적으로는 전역 스코프에 도달함.
- 변수가 존재하기만 하고 한 번도 해당 변수에 접근하지 않은 경우에도 클로저를 관찰할 수 없음.
- 함수를 호출하지 않는 경우에도 클로저를 관찰할 수 없음.

### 7.1.6 관찰 가능성 관점에서 클로저의 정의

> *클로저는 함수가 외부 스코프의 변수를 사용하면서
그 변수에 접근 가능하지 않은 다른 스코프에서 실행될 때 관찰됩니다.*
> 
- 이 정의의 핵심
    - 반드시 함수와 관련되어야 한다.
    - 외부 스코프의 변수를 적어도 하나 이상 참조해야한다.
    - 참조하려는 변수가 있는 스코프 체인의 다른 분기에서 함수를 호출해야 한다.
- **개발할 때 클로저의 존재와 그 효과를 고려하며 설계하는 게 중요!**

### 7.2 클로저 생명주기와 가비지 컬렉션

- 클로저는 본질적으로 함수의 인스턴스와 연결되므로 이 함수를 참조하는 함수가 있는 한 변수에 대한 클로저는 지속됩니다.
