# CHAPTER 8. 모듈 패턴

> 이번 장에서는 모든 프로그래밍에서 가장 중요한 코드 구성 패턴인 **모듈 패턴**을 살펴보고 책을 마무리 짓습니다.
앞선 핵심 주제를 모듈로 구현해 프로그램 구축을 구체적이고 실용적으로 개선하는 방법을 살펴봅니다.
> 

### 8.1 캡슐화와 최소 노출의 원칙(POLE)

- 캡슐화는 객체 지향 프로그래밍의 원칙으로 자주 거론되는데, 사실 캡슐화는 그보다 더 근본적이며 광범위하게 적용된다.
- 캡슐화의 목표는 정보(데이터)와 동작(함수)을 한데 묶거나 함께 배치해 공통의 목적을 달성하는 것.
- 구문이나 코드 메커니즘과 관계없이 **캡슐화는** **공통의 목적을 가진 코드 일부분을 별도의 파일에 옮기는 것만으로도 실현할 수 있음.**
    - ex) 검색 결과 목록을 `search-list.js`라는 단일 파일로 묶는 것도 캡슐화.
- 모던 프런트엔드 개발에서는 UI 설계 시 컴포넌트를 기본 단위로 하는데 이는 캡슐화의 필요성을 더욱 부각함.
    - 검색 결과를 보여주는 화면을 구현한다고 가정
    - 상당수의 프런트엔드 개발자는 **마크업**과 **스타일**, **프로그램 로직**을 **하나의 단위로 통합**하고 여기에 SearchList라는 컴포넌트 이름을 붙인다.
    - 캡슐화를 통해 코드의 **가독성, 재사용성, 유지보수성**을 높이는 것이 컴포넌트 기반 개발의 핵심
- 캡슐화의 또 다른 주요 목표는 **캡슐화된 데이터와 함수의 특정 측면의 가시성을 제어하는 것**입니다.
    - **최소 노출의 원칙(POLE)은** 변수와 함수 모두에 영향을 줬습니다.
    - **JS**에서는 주로 **렉시컬 스코프** 메커니즘을 사용해 가시성 제어라는 목표를 달성함.
- 캡슐화의 주요 아이디어는 비슷한 코드를 그룹화하고, 공개하고 싶지 않은 세부 사항은 접근을 선택적으로 제한하는 것.
- 비공개(private)로 분류되지 않은 부분은 공개(public)로 표시하고 프로그램 전체에서 접근할 수 있게 함.
- 이런 노력을 기울이다 보면 자연스럽게 코드를 체계화할 수 있습니다. 공개와 비공개의 경계, 둘의 연결 지점이 어딘지 알고 나면 소프트웨어 구축과 유지 보수가 쉬워집니다.
- 또한 데이터와 함수 과다 노출을 피할 수 있어 높은 품질의 코드를 유지할 수 있습니다.

### 8.2 모듈이란

- 모듈은 관련된 데이터와 함수(문맥상 메서드라고도 함)의 모음이다.
- 모듈에서는 숨겨진 비공개 세부 정보와 공개적으로 접근 가능한 세부 정보를 구분하는데, 후자를 **공개 API**라 부름.
- 모듈도 상태를 유지합니다. 모듈은 일부 정보를 장기간 유지하며 해당 정보에 접근하고 이를 업데이트하는 기능도 제공합니다.

> **NOTE_** 모듈 패턴의 주요 관심사는 느슨한 결합을 통한 모듈화나 기타 프로그램 아키텍처 기술을 통해 시스템 수준의 모듈화를 완전히 수용하는 데 있습니다.
> 

지금부터는 모듈이 아닌 다른 유용한 코드 패턴과 모듈 패턴을 비교하며 모듈의 특성을 이해해보겠습니다.

### 8.2.1 네임스페이스(무상태 그룹화)

- 데이터 없이 관련된 함수를 그룹으로 묶는 것은 모듈에서 이야기하는 캡슐화가 아닙니다. 이러한 무상태 함수를 모아놓은 것을 **네임스페이스**라고 부릅니다.
    
    ```jsx
    	// 모듈이 아닌 네임스페이스
    
    var Utils = { 
    	cancelEvt(evt) { evt.preventDefault();
    		evt.stopPropagation();
    		evt.stopImmediatePropagation();
    	}, 
    	wait(ms) { 
    		return new Promise(function c(res){
    		 setTimeout(res, ms);
    		});
    	}, 
    	isValidEmail(email) { 
    		return /[^@]+@[^@.]+\.[^@.]+/.test(email);
    	},
    }
    ```
    
    - 여기서 Utils는 유용한 유틸리티 모음이지만, 모두 상태 독립적인 함수입니다.
    - 일반적으로 기능을 한데 모으는 것은 모범 사례이지만 그렇다고 해서 모듈이 된 것은 아닙니다.
    - 여기서 Utils는 함수를 체계화한 네임스페이스입니다.

### 8.2.2 데이터 구조(상태 유지 그룹화)

- 데이터와 상태를 가진 함수를 하나로 묶는다 하더라도 **데이터의 가시성을 제한하지 않는다면 POLE 관점에서 캡슐화가 아님.** 이런 경우 모듈이라는 이름이 적절치 않습니다.
- 예시 코드
    
    ```jsx
    // 모듈이 아닌 데이터 구조 
    var Student = { 
    	records: [ 
    		{ id: 14, name: "카일", grade: 86 }, 
    		{ id: 73, name: "보라", grade: 87 }, 
    		{ id: 112, name: "지수", grade: 75 }, 
    		{ id: 6, name: "호진", grade: 91 } 
    	], 
    	getName(studentID) { 
    		var student = this.records.find( student => student.id == studentID );
    		return student.name;
    	}
    };
    
    Student.getName(73);
    // 보라
    ```
    
    - 위 코드에서 `records`는 **공개적으로 접근**할 수 있고 공개 API를 통해서만 접근할 수 있지 않기 때문에 `Student`는 모듈이 아닙니다.
    - 데이터와 함수를 모아놓았다는 측면에서 `Student`는 캡슐화와 관련이 있지만 가시성 통제 측면(POLE 관점)에서는 그렇지 않습니다.
    - 이런 경우는 데이터 구조의 인스턴스라는 이름을 붙이는 게 좋음.
- 모듈화된 코드 예시
    
    ```jsx
    // 클로저를 사용한 모듈 패턴(즉시 실행 함수, IIFE)
    const studentModule = (function (){
    	const records = {
    		{ id: 14, name: "카일", grade: 86 },
        { id: 73, name: "보라", grade: 87 },
        { id: 112, name: "지수", grade: 75 },
        { id: 6, name: "호진", grade: 91 }
    	};
    	
    	return {
    		getName(studentID) {
          const student = records.find(student => student.id === studentID);
          return student ? student.name : null;
        }
    	}
    })();
    
    console.log(Student.getName(73)); // 보라
    console.log(Student.records);    // undefined
    ```
    
    1. `records`는 클로저 안에 숨겨져 있어(캡슐화) 외부에서 접근할 수 없습니다.
    2. 데이터를 조작하거나 읽을 수 있는 방법은 `getName`이라는 공개 API를 통해서만 가능합니다.
    - IIFE를 사용하는 것은 프로그램에서 해당 모듈 인스턴스 하나만 필요하다는 것을 의미합니다.
    - 이 때 이 단일 인스턴스를 싱글턴이라 부릅니다.
    - **모듈 팩토리(다중 인스턴스)**  형태로 지원하는 모듈을 정의하고 싶다면 함수를 IIFE로 정의하지 않고 일반적인 독립형 함수로 정의하면 됩니다. 이를 **모듈 팩토리** 함수라고 부릅니다.

### 8.2.3 모듈(상태를 가진 접근 제어)

- 모듈 패턴이 가진 정신을 실체화하려면 상태와 함수를 그룹화하는 것뿐만 아니라 가시성(공개 vs. 비공개) 제어를 통한 통제도 필요합니다.
- 앞선 절에서 살펴본 Student를 모듈로 바꿔봅시다. 2000년대 초반, 처음 등장했을 때 ‘노출식 모듈’ 이라 불렀던 ‘클래식 모듈’형식으로 바꿔보겠습니다. 결과는 [**다음과 같습니다.**](https://www.notion.so/CHAPTER-8-182c7bdaffa48064a20cdf468a3fc0b2?pvs=21)
- **클래식 모듈의 정의(필요조건):**
    1. 적어도 한 번 이상 실행되는 모듈 팩토리 함수가 외부 스코프에 존재해야 합니다.
    2. 모듈의 내부 스코프에는 해당 모듈의 상태를 나타내는 정보가 최소한 하나 이상 있어야 하며, 이는 외부에서 접근할 수 없어야 합니다.(가시성 통제 측면, POLE)
    3. 모듈은 하나 이상의 함수를 공개 API로 반환해야 합니다. 이 함수는 내부 스코프의 숨겨진 상태를 클로저를 통해 보존, 관리합니다.
    - 위 조건들을 만족하면 클래식 모듈이라 할 수 있는데, 클래식 모듈은 프로그램의 요구 사항과 상황에 따라 변형될 수 있습니다.

### 8.3 Node.js의 CommonJS 모듈

- 클래식 모듈은 다른 코드나 또 다른 모듈과 함께 하나의 파일 내에서 묶일 수 있지만 **CommonJS 모듈은 파일 기반이어서 모듈을 만들 때 별도의 파일을 정의해야 한다**는 차이가 있음.
- CommonJS 모듈 코드 예시
    
    ```jsx
    module.exports.getName = getName;
    
    // ************************
    
    var records = [ 
    	{ id: 14, name: "카일", grade: 86 }, 
    	{ id: 73, name: "보라", grade: 87 }, 
    	{ id: 112, name: "지수", grade: 75 }, 
    	{ id: 6, name: "호진", grade: 91 } 
    ];
    
    function getName(studentID) { 
    	var student = records.find( 
    		student => student.id == studentID 
    	);
    	
    	return student.name;
    }
    ```
    
    - 4장에서 설명한 것처럼 records와 getName 식별자는 모듈의 최상위 스코프에 있지만 전역 스코프는 아닙니다.
    - 따라서 여기 있는 모든 코드는 기본적으로 바깥 코드에 대해 비공개입니다.
    - CommonJS 모듈에서는 module.exports 객체를 사용해 모듈의 공개 API를 정의합니다.
    - 필자는 주로 exports를 상단에, 모듈 구현을 하단에 배치하는걸 선호 및 권장.
- 일부 개발자는 기본 exports 객체를 다음과 같이 바꾸는 습관이 있음
    
    ```jsx
    // API를 위한 새로운 객체 정의
    module.exports = {
    	// ...내보낼 것에 대한 정의...
    }
    ```
    
    - 이 접근 방식에는 여러 모듈이 순환적으로 종속되는 경우 예기치 않은 동작이 발생하는 등 몇 가지 특이점이 있음. 필자는 객체를 교체하지 않는 것을 권장.
- 여러 개를 동시에 내보내고 싶다면 다음과 같이 객체 리터럴 스타일 정의를 사용하면 됨.
    
    ```jsx
    Object.assign(module.exports, {
    	// ...내보낼 것에 대한 정의...
    });
    ```
    
    - 이렇게 하면 모듈의 공개 API로 삼을 것을 {} 객체 리터럴에 정의하고, Object.assign()을 사용해 얕은 복사로 module.exports에 여러 속성을 한 번에 추가할 수 있습니다. 편리함과 안전함 사이에서 절묘한 조화와 균형을 이룬 방법입니다.
- 작업 중인 모듈이나 프로그램에 또 다른 모듈 인스턴스를 추가하려면 Node.js의 require()메서드를 사용하세요.
    
    ```jsx
    var Student = require("/path/to/student.js");;
    
    Student.getName(73);
    // 보라
    ```
    
    - Student는 이제 모듈 예시에서 사용했던 공개 API를 참조합니다.
    - require()로 불러와도 모두 같은 모듈 인스턴스에 대해 참조를 얻습니다.
- require() 함수를 사용하면 지정된 모듈 파일의 전체 공개 API가 불러와집니다. 모 아니면 도..
모듈의 일부분만 필요한 경우에는 다음처럼 해야 합니다.
    
    ```jsx
    var getName = require("/path/to/student.js").getName;
    
    // 또는 다음과 같이 모듈의 일부를 가져옴(구조 분해 할당)
    
    var { getName } = require("/path/to/student.js");
    ```
    
    - 클래식 모듈과 마찬가지로 CommonJS 모듈 API에서 공개적으로 내보내진 메서드는 내부 모듈 세부 사항에 대한 클로저를 유지합니다.
    - 이를 통해 프로그램이 살아 있는 동안 모듈 싱글턴의 상태가 유지됩니다.

### 8.4 최신 ES 모듈

- ES 모듈(ESM)은 CommonJS와 약간 유사합니다. ES 모듈은 파일 기반이고 모듈 인스턴스는 싱글턴이며 모든 것은 기본적으로 비공개입니다.
- 둘 사이 눈에 띄는 차이점은 **ES 모듈은 파일 상단에 전처리 구문 use strict가 없어도 엄격 모드로 실행된다는 점입니다.**
- ES 모듈은 CommonJS의 module.exports가 아닌 export 키워드를 사용해 모듈의 공개 API에 특정 내용을 노출합니다. 그리고 require() 대신 import 키워드를 사용합니다.
    
    ```jsx
    export { getName };
    
    // **************************
    
    var records = [ 
    	{ id: 14, name: "카일", grade: 86 }, 
    	{ id: 73, name: "보라", grade: 87 }, 
    	{ id: 112, name: "지수", grade: 75 }, 
    	{ id: 6, name: "호진", grade: 91 } 
    ];
    
    function getName(studentID) { 
    	var student = records.find( 
    		student => student.id == studentID 
    	);
    	
    	return student.name;
    }
    ```
    
    - 코드에서 `export { getName }` 구문만 변경되었습니다.
    - CommonJS 포맷과 마찬가지로 export는 파일 어디에서나 사용할 수 있지만 최상위 스코프에 있어야 합니다. 다른 블록이나 함수 안에 있으면 안 됩니다.
- ES 모듈에서는 다양한 방법으로 export 문을 지정할 수 있습니다.
    
    ```jsx
    export function getName(studentID) {
    	// ...
    }
    ```
    
    - function 앞에 export 키워드가 있지만 여전히 함수 선언문이라서 getName은 함수 호이스팅 규칙을 적용받기 때문에 모듈 전체 스코프에서 사용할 수 있습니다.
- 위 예시를 다음과 같이 변형할 수도 있습니다.
    
    ```jsx
    export default function getName(studentID) {
    	// ...
    }
    ```
    
    - **default 키워드를 붙여서 모듈을 노출하는 형태를 ‘기본 내보내기’**라 하는데 일반 내보내기와는 동작이 다릅니다.
    - 내보낼 API 객체에 멤버 변수가 하나 있는 경우 기본 내보내기를 하면 간단한 문법으로도 해당 모듈을 import할 수 있습니다.
    - defulat가 붙지 않는 내보내기는 **기명 내보내기**라고 합니다.
- import 키워드도 export처럼 모듈 최상위 레벨에서만 사용해야 하며 블록이나 함수 안에 있으면 안 됩니다. import 키워드도 다양하게 변형되어 사용할 수 있습니다.
- **기명 가져오기 예시:**
    
    ```jsx
    import { getName as getStudentName } from "/path/to/student.js";
    
    getStudentName(73); // 보라
    ```
    
- getName이 student.js에서 기본 내보내기로 내보내졌다면 다음과 같이 가져올 수 있습니다.
    
    ```jsx
    import getName from "/path/to/students.js";
    
    getName(73); // 보라
    ```
    
- 기본 내보내기한 멤버와 기명 내보내기한 멤버를 함께 가져오려면 다음과 같이 코드를 작성하면 됩니다
    
    ```jsx
    import { default as getName, /* ... 기명 내보내기한 멤버 나열 ... */ } from "path/to/students.js";
    
    getName(73); // 보라
    ```
    
- **네임스페이스 가져오기도** import를 사용한 주요 변형 중 하나입니다.
    
    ```jsx
    import * as Student from "/path/to/studnet.js";
    
    Student.getName(73); // 보라
    ```
    
    - * 를 사용하면 API로 내보낸 모든 멤버(기본, 기명 모두)를 가져와 지정된 단일 네임스페이스 식별자(Student)아래에 저장할 수 있습니다.
    - 이 변형은 다양한 모듈 변천사에서 클래식 모듈 포맷과 가장 유사합니다.

### 8.5 정리

- 클래식 모듈(브라우저나 Node.js), CommonJS(Node.js), 또는 ES 모듈(브라우저나 Node.js)을 사용하든 관계없이 모듈은 프로그램의 기능과 데이터를 구조화하고 정리하는데 가장 효과적인 방법입니다.
- **렉시컬 스코프 규칙을 사용해 변수와 함수를 적절한 위치에 배치하는 방법을 배워 모듈 패턴을 효율적으로 사용하자는 것**이 이 책의 결론이자 여정의 끝입니다. POLE은 우리가 항상 취해야하는 기본 자세로, 과도한 노출을 피하고 필요한 최소한의 부분만 공개 API에 노출해 상호작용하세요.
- 모듈 아래에서 클로저는 렉시컬 스코프 시스템을 활용해 모듈 상태를 유지하는 역할을 하니 렉시컬 스코프도 알아두세요.
