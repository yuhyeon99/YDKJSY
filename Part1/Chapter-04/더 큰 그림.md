### 4.1 첫 번째 기둥: 스코프와 클로저

- 함수나 블록 단위로 변수의 스코프(유효 범위)를 한정 짓는 것은 모든 프로그래밍 언어의 근본적인 특징
- **스코프 =** **양동이**, **변수 =** **양동이에 넣을 구슬**에 비유 할 수 있음.
    - 이 때 **스코프 모델**은 구슬과 같은 색을 가진 양동이를 찾도록 도와주는 규칙입니다.
        - 즉, 변수(구슬)가 어느 스코프(양동이)에 속해있는지 찾는 규칙
        - **안쪽 스코프에서 바깥쪽 스코프의 변수는 볼 수 있지만, 그 반대는 불가하다는 규칙**
        
        ```jsx
        function outerFunction() {
          var outerVariable = "outer"; // 바깥 스코프의 변수 (양동이)
          
          function innerFunction() {
            var innerVariable = "inner"; // 안쪽 스코프의 변수 (양동이)
            
            console.log(outerVariable); // "outer" 출력 (안쪽에서 바깥 스코프 접근 가능)
            console.log(innerVariable); // "inner" 출력
          }
          
          innerFunction();
          // console.log(innerVariable); // 오류: 바깥에서는 안쪽 스코프에 접근할 수 없음
        }
        
        outerFunction();
        ```
        
- 대부분의 프로그래밍 언어는 이런 작동 방식을 취하며 이를 **렉시컬 스코프(어휘 스코프)**라고 부릅니다.

### 렉시컬 스코프가 결정되는 시점

- **논리적:**
    - 개발자가 코드를 작성할 때. 즉, 코드를 작성하는 과정에서 어떤 변수가 어떤 스코프에 속하는지 이미 명확하게 정의됨
- **물리적:**
    - 자바스크립트 엔진이 실제로 렉시컬 스코프를 결정하는 시점은 자바스크립트 파일이 파싱 또는 컴파일될 때.
    - 컴파일 또는 파싱 과정에서 [🔗**스코프 모델 규칙**](https://www.notion.so/CHATPER-4-103c7bdaffa480f6a77ed44a767a7341?pvs=21)을 실제로 적용하여 결정
- 두 관점의 공통점은 **스코프 결정이 실행 전에 미리 고정된다는 점**에서 매우 중요한 특징

### 4.1.1 JS만의 독특한 렉시컬 스코프 특징(호이스팅)

- 호이스팅이란?
    - 특정 스코프 내에 선언한 변수가 선언된 위치와 상관없이 해당 스코프 시작 부분에서 선언한 것마냥(끌어올려진 것 처럼) 처리되어 호이스팅이란 이름이 붙었음
    
    ```jsx
    // x가 호이스팅 되는 곳
    console.log(x); // undefined
    var x = 5;
    ```
    
    ```jsx
    console.log(x);  // ReferenceError: x is not defined, 
    // 변수x의 함수 스코프 외부에 존재하기 때문에 ReferenceError이 발생하게 됨
    function test() {
    // x가 호이스팅 되는 곳
        var x = 1;   // 함수 test 안에서만 x가 유효함
    }
    ```
    

### 4.1.2 JS만의 독특한 렉시컬 스코프 특징(함수 스코프와 TDZ)

- `var`을 사용해 선언한 변수는 해당 변수를 선언한 블록 위치와 상관없이 **함수 기준으로 스코프가 만들어짐**
- `let/const`는 `var`과 다르게 **블록 스코프**에서 작동함. 중요한 차이점은 **TDZ**
    - **TDZ(Temporal Dead Zone)**:
    변수 선언 이전에 해당 변수를 **사용할 수 없는 구간**입니다. 변수가 블록 안에서 선언되었지만, **선언되기 전에는 해당 변수를 참조하면 오류가 발생**합니다.
    
    ```jsx
    console.log(a); // ReferenceError: a is not defined (TDZ에 있음)
    let a = 10;
    ```
    
    - 그러나 호이스팅은 `var` 와 동일하게 작동함.
    - 그렇다면 굳이 `let`과 `const`에 호이스팅을 적용한 이유가 있을까? ECMA의 의도가 궁금
        - 자바스크립트 언어의 일관성과 **변수 선언 방식의 통일성**을 유지하기 위한 ECMA의 설계 목적과 관련이 있습니다
        - 만약 `let`과 `const`가 호이스팅되지 않는다면, **자바스크립트 엔진이 특정 변수의 선언 위치**에 따라 **다르게 처리**해야 하므로 언어의 **일관성이 깨질** 수 있습니다.
        

### [🔗4.1.1](https://www.notion.so/CHATPER-4-103c7bdaffa480f6a77ed44a767a7341?pvs=21)과 [🔗4.1.2](https://www.notion.so/CHATPER-4-103c7bdaffa480f6a77ed44a767a7341?pvs=21)의 특징으로 인해서 JS가 렉시컬 스코프 모델을 사용하지 않는다는 주장의 근거로 사용될 때가 있는데, 이는 부적합함.

- **호이스팅은 자바스크립트의 실행 방식**일 뿐, 렉시컬 스코프 모델 자체와는 상관이 없습니다.
- TDZ가 렉시컬 스코프를 방해한다는 오해
    - TDZ는 오히려 **렉시컬 스코프 모델을 강화**하는 기능입니다. **변수가 선언된 위치를 명확히** 하여, 선언 이전에 변수를 사용하는 **의도하지 않은 버그를 방지**합니다. 즉, **TDZ는 렉시컬 스코프에 맞는 변수가 선언된 이후에만 변수를 사용할 수 있도록 규제**하는 메커니즘입니다. 이것은 렉시컬 스코프 모델을 따르는 중요한 특징입니다.
- 함수 스코프가 렉시컬 스코프를 방해한다는 오해
    - 자바스크립트의 **함수 스코프**는 **렉시컬 스코프의 일부**로, 여전히 코드 작성 시점에서 스코프가 결정됩니다. **함수 스코프**가 블록 스코프와 다르게 동작한다는 점은 단지 자바스크립트의 스코프 모델의 차이일 뿐, 렉시컬 스코프 자체를 부정하는 것은 아닙니다. 자바스크립트는 여전히 **함수의 정의된 위치**를 기준으로 **렉시컬 스코프**를 따릅니다.

### 4.1.3 클로저

- JS 같이 함수를 일급값(First-Class Value)으로 취급하는 언어에서 렉시컬 스코프 모델을 사용하면 자연스레 나타나는 결과
    - **일급값(First-Class Value)이란?**
        - 프로그래밍 언어에서 **다른 값들과 동등하게 취급되는 값**을 의미
            1. **변수에 할당 가능**
            
            ```jsx
            const myFunc = function() { return "Hello"; };
            ```
            
            1. **데이터 구조에 저장 가능**: 배열이나 객체와 같은 데이터 구조 안에 저장할 수 있음.
            
            ```jsx
            const funcs = [function() { return "A"; }, function() { return "B"; }];
            ```
            
            1. **함수의 인수로 전달 가능**: 함수는 다른 함수의 인자로 전달될 수 있습니다.
            
            ```jsx
            function execute(fn) {
              return fn();
            }
            execute(function() { return "Executed"; });
            ```
            
            1. **함수의 반환 값으로 사용 가능**: 함수는 다른 함수를 반환할 수 있습니다.
            
            ```jsx
            function createFunction() {
              return function() { return "Created Function"; };
            }
            const newFunc = createFunction();
            ```
            
    - 일급값과 렉시컬 스코프의 연관성
        - 자바스크립트는 함수가 일급값으로 취급되므로, 함수 내에서 정의된 변수가 함수가 **정의된 시점**의 스코프(렉시컬 스코프)에 따라 결정됩니다. 따라서 함수가 변수나 인자로 전달될 때에도 그 **정의된 환경**을 기억하고 있어서, 코드 어디에서든 함수가 호출되더라도 **정의 당시의 스코프**에 접근할 수 있습니다. 이를 **클로저(Closure)**라고 합니다.
        - [**🔗클로저 예시 코드 링크**](https://www.notion.so/CHAPTER-3-1f8c85159afe4f5a850cacb862a296d1?pvs=21)
