# 1.2 자바스크립트 이름의 유래

- 자바스크립트는 자바와 관련이 없습니다.
- 마케팅 목적으로 고안된 이름입니다.
- `JS`의 공식 명칭은 ECMA 표준 기구에 의해 **ECMAScript**가 되었습니다.
- 2016년부터는 ECMAScript에 개정 연도를 붙이기 시작했으며, 현재는 **ECMAScript 2019**(약어로 ES2019)가 되었습니다.

## 1.3 명세서

- **TC39**는 자바스크립트의 공식 명세를 관리하는 기술 운영 위원회입니다.
- TC39 위원이 정기 모임에서 변경 사항을 제출하면 명세서가 업데이트되며, 이후 명세서에 따라 자바스크립트의 문법과 작동 방식이 결정됩니다.
- 새로운 아이디어는 TC39 회원이 아닌 누군가가 비공식 수단(블로그, 소셜미디어 등)을 통해 제안할 수 있으며, TC39 위원 중 한 명이 이 아이디어를 가치 있다고 생각해 옹호하면 제안이 '0단계'로 올라갑니다.
- 자바스크립트에는 버전이 없으며, 명세서 하나로 유지됩니다.
- 브라우저 엔진별로 명세서 개정안을 반영하는 시기가 다르긴 하지만, 규칙을 어기는 일은 없어야 합니다.
    - 예: 크롬의 엔진인 V8이 모질라의 엔진 스파이더멍키와 호환되지 않는 기능을 구현하는 일은 절대 없어야 합니다.

### 1.3.1 자바스크립트를 지배하는 웹

- **역사**: 브라우저 제조사들은 명세서 개정안을 반영했을 때 기존에 잘 보이던 콘텐츠가 깨지면, 개정안을 반영하지 않기로 결정했습니다.
- 불일치가 발생하면 TC39 위원회는 종종 기존 결정을 철회하고 명세서를 웹에 맞춤화합니다.
    - 예: `contains()` 메서드를 추가하려다 몇몇 JS 프레임워크와 충돌이 발생한다는 것을 발견하고, 메서드명을 `includes()`로 수정한 사례.
- 때때로 TC39는 브라우저 기반 자바스크립트 엔진이 명세서를 준수할 가능성이 거의 없더라도 명세서를 변경하지 않는 경우가 있습니다.
    - 이 경우, 웹이 아닌 다른 엔진에서 사용될 가능성이 있는 경우입니다.
    - 이러한 명세들은 부록 B에 적힌 예외를 참고해 브라우저에 반영할 수 있습니다.
    - **B.1**과 **B.2** 절은 웹에서는 사용되지만 명세서에 등재되지 않은 자바스크립트 문법과 API를 다룹니다.
    - **B.3** 절에서는 웹 엔진과 웹이 아닌 엔진 모두에서 실행되지만, 작동 결과가 달라 문제를 초래할 수 있는 문법과 의미론(시맨틱스)을 다룹니다.

### 1.3.2 자바스크립트지만 자바스크립트가 아닌 웹 전용 문법

- 브라우저 엔진, Node.js 등 자바스크립트가 실행되는 환경은 전역 스코프에 API를 추가해 자체적으로 사용할 수 있는 기능을 제공합니다.
    - 예: `alert()` 함수, `console.*` 메서드.

### 1.3.3 모든 코드가 자바스크립트인 것은 아님

- 개발자 도구는 개발자 경험(DX)을 최우선으로 두기 때문에, 명세를 정확히 재현하지 않을 수 있습니다.
- 개발자 도구가 자바스크립트의 프로그램 처리 방식을 항상 엄격하게 준수하지 않는다는 점을 알고 있어야 합니다.

## 1.4 자바스크립트의 다양한 얼굴

- **프로그래밍 패러다임**은 코드를 구조화하는 방법과 사고방식을 의미합니다.
- 절차적, 객체지향적, 함수형 패러다임이 널리 알려져 있으며, 패러다임에는 옳고 그름이 없습니다.
- 자바스크립트는 다중 패러다임 언어라 절차적, 객체지향, 함수형 스타일의 코드를 모두 작성할 수 있습니다.

## 1.5 하위 호환성과 상위 호환성

- **하위 호환성**이란 단 한 번이라도 유효한 자바스크립트 문법으로 인정되면, 명세서가 변경되더라도 그 유효성이 깨지지 않는다는 의미입니다.
    - 즉, 예전에 작성한 코드는 시간이 지나도 작동할 것을 보장받습니다.
- **상위 호환성**이란 새로운 명세서에 추가된 문법으로 작성한 코드가 구형 자바스크립트 엔진에서 문제가 발생하지 않아야 한다는 것을 의미합니다.
- **자바스크립트는 하위 호환성은 보장하지만, 상위 호환성은 보장하지 않습니다.**

### 1.5.1 간극을 줄이기 위한 노력

- 상위 호환성이 보장되지 않기에, 오래된 엔진에서는 새로운 문법으로 작성한 코드가 작동하지 않을 가능성이 있습니다.
- 이를 해결하는 방법 중 하나는 **트랜스파일**을 통해 호환성 문제를 해결하는 것입니다.
    - **트랜스파일**이란 한 형태에서 다른 형태로 소스 코드를 변환하는 것을 의미합니다.
    - 트랜스파일러로는 주로 **바벨(Babel)**을 사용합니다.
- 개발자는 이러한 호환성 문제를 도구에 맡기고, 새로운 문법을 활용해 클린한 코드를 작성하는 데 집중해야 합니다.

### 1.5.2 간극을 메우기 위한 방법 찾기

- 상위 호환성 문제가 새로운 문법이 아닌, 근래에 추가되었지만 아직 지원하지 않는 API 메서드 때문에 발생했다면, 메서드 정의를 추가해 이 메서드가 오래된 환경에도 있었던 것처럼 해야 합니다.
- 이러한 패턴을 **폴리필**이라고 합니다.
- 바벨과 같은 트랜스파일러는 폴리필 기능이 내장되어 있어, 필요한 코드를 찾아 자동으로 폴리필을 추가합니다.

## 1.6 인터프리터 이해하기

- 자바스크립트가 인터프리터 언어인가, 컴파일러 언어인가에 대한 논쟁이 있습니다.
    - 기준은 파싱을 거치는 언어인지 아닌지에 중점을 둡니다.
- 자바스크립트는 파싱을 거치는 언어라 컴파일 언어에 가깝습니다.
    - 파싱이 끝난 코드는 컴파일러를 거쳐 최적화된 이진 코드로 변환된 후 실행됩니다.

### 1.6.1 자바스크립트 소스 코드의 실행 절차

1. 코드를 바벨이 트랜스파일합니다. 이후 웹팩을 비롯한 번들러를 거쳐 번들링되고, 그 결과가 자바스크립트 엔진에 전달됩니다.
2. 자바스크립트 엔진은 전달받은 코드를 파싱해 **AST(추상 구문 트리)**로 변환합니다. (컴파일러 언어적 요소)
3. 이어서 엔진은 추상 구문 트리를 이진 바이트 코드로 변환합니다. 이 과정에서 JIT 컴파일러가 작동하며 그때그때 최적화가 진행됩니다. (인터프리터 언어적 요소)
4. 마지막으로 자바스크립트 가상 머신이 프로그램을 실행합니다.

### 1.6.2 웹어셈블리

- **웹어셈블리(Wasm)**은 자바스크립트가 주력이 아닌 개발자도 자바스크립트 엔진에서 돌아가는 코드를 쉽게 작성할 수 있게 해주는 데 목적이 있습니다.
- Wasm은 프로그램 형태로 제작되어 실행 전 단계인 파싱과 컴파일을 거치지 않습니다.
- Wasm은 성능 향상을 위해 만들어졌습니다. (파싱, 컴파일은 실행 직전에 이루어지고, 배포는 자바스크립트 엔진의 별도 처리가 거의 필요 없는 바이너리 파일 형식으로 진행됩니다.)
- Wasm을 사용하면 다른 언어에서 사용하는 기능, 특히 트랜스파일을 거치는 프로그램 전용으로 설계된 기능을 자바스크립트에 추가해야 한다는 압박이 줄어듭니다.
- 최근 Wasm은 웹과 관련 없이 프로그램을 컴파일한 후 다양한 시스템 환경에서 실행할 수 있도록 해주는 **크로스 플랫폼 가상 머신(VM)**으로 진화하고 있습니다.

## 1.7 엄격 모드

- 엄격 모드는 기본이 아닌 선택 사항입니다.
- 엄격 모드는 자바스크립트 엔진이 코드를 최적화하고 효율적으로 실행할 수 있게 해주는 '안내 가이드' 역할을 합니다.
- 린터와 같은 도구를 사용해 엄격 모드로 작업하면, 비엄격 모드에서 발생할 수 있는 실수와 문제를 미연에 방지할 수 있어 협업이 수월해집니다.
- 엄격 모드에서만 활성화되는 가이드 대부분은 **초기 오류**의 형태를 띕니다.
    - 초기 오류는 구문 오류는 아니지만, 코드 실행 전 컴파일 단계에서 잡아낼 수 있는 오류입니다.
- 파일 단위로 엄격 모드를 적용하려면 전처리 구문 `"use strict";`를 사용해야 하며, 이 구문 앞에는 주석이나 공백 이외의 내용이 허용되지 않습니다.
- 파일 단위 엄격 모드가 적용된 경우, 함수 단위의 엄격 모드는 사용할 수 없습니다.
    - 둘 중 하나만 선택해야 합니다.
    - 함수 단위 엄격 모드는 비엄격 모드에서 작성된 기존 프로그램에 점진적으로 엄격 모드를 적용할 때만 사용하는 것이 좋습니다.
- 엄격 모드가 기본이 아닌 이유:
    - 원본 코드가 비엄격 모드에서 작성되었더라도 트랜스파일된 코드는 사실상 엄격 모드를 준수하게 됩니다.
    - ES6 모듈 형식으로 만든 파일은 자동으로 엄격 모드를 준수하기 때문입니다.

## 문제 풀이

### 문제 1: 자바스크립트의 이름과 역사

**질문:** 자바스크립트의 이름이 '자바스크립트'로 정해진 이유와, ECMAScript라는 명칭이 사용되기 시작한 시기를 설명하세요.

**힌트:** 자바스크립트와 자바의 관계, ECMAScript 표준화 시점.

**정답:**

자바스크립트의 이름은 자바와 직접적인 관련이 없지만, 당시 자바(Java) 언어의 인기가 높았기 때문에 마케팅 목적으로 '자바스크립트'라는 이름이 붙여짐. **자바스크립트의 공식 명칭**은 **1997년**을 시작으로 ECMA 국제 표준화 기구에 의해 **ECMAScript**로 정해졌으며, **2016년**부터 ECMAScript에 **개정 연도**를 붙이기 시작함.

참조: [**ECMAScript 아카이브(1997-2015)](https://www.notion.so/IT-https-it-rank-netlify-app-27dc4f033e3a4e49a7f20c151ea05598?pvs=21),** 

### 문제 2: TC39의 역할과 명세서 업데이트 과정

**질문:** TC39는 자바스크립트의 명세서 관리에 어떤 역할을 하며, 새로운 자바스크립트 기능이 명세서에 포함되기까지의 과정을 단계별로 설명하세요.

**힌트:** '0단계'에서 시작해 최종 명세서 업데이트까지의 과정.

**정답:** 

1. 새로운 아이디어가 비공식적으로 제안됨.
(TC39위원을 제외한 어떤 이의 의견을 TC39위원이 채택)
2. TC39 위원 중 한 명이 이 아이디어를 옹호하면, 아이디어는 ‘0단계’로 승격됨.
3. 이후 여러 단계의 검토와 개선 과정을 거치며, 최종적으로 TC39 위원회에서 명세서에 포함할지 결정함.
4. 명세서가 업데이트되면 브라우저 엔진이 이를 구현함.
    - 참조 링크: [TC39 위원회 공식 페이지](https://tc39.es/)

### 문제 3: 하위 호환성과 상위 호환성의 차이

**질문:** 자바스크립트에서 하위 호환성과 상위 호환성의 차이는 무엇인가요? 하위 호환성을 보장하지만 상위 호환성을 보장하지 않는 이유는 무엇인가요?

**힌트:** 새로운 문법과 기존 문법의 유지에 관한 차이점을 설명하세요.

**정답:**

- **하위 호환성**은 기존에 유효했던 자바스크립트 문법이 명세서가 변경되더라도 계속해서 유효하다는 것을 의미함. 반면, **상위 호환성**은 새로운 명세서에 추가된 문법이 구형 자바스크립트 엔진에서도 작동할 수 있음을 의미함. 자바스크립트는 하위 호환성을 보장하지만, 상위 호환성을 보장하지 않음.
- **하위 호환성을 보장하지만 상위 호환성을 보장하지 않는 이유는 기존 코드를 최대한 오래 유지하기 위해서임.**

상위 호환성 문제를 해결하기 위해 트랜스파일링과 폴리필 기술을 사용해서 해결함.

### 문제 4: 트랜스파일링과 폴리필의 역할

**질문:** 오래된 자바스크립트 엔진에서 최신 문법을 사용할 때 발생할 수 있는 문제를 해결하기 위한 두 가지 방법인 트랜스파일링과 폴리필의 차이점을 설명하세요.

**힌트:** 바벨(Babel)과 폴리필의 사용 목적과 방법을 비교해보세요.

**정답:** 

**트랜스파일링**은 최신 자바스크립트 **문법**을 오래된 자바스크립트 엔진에서도 실행 가능하도록 구버전 문법으로 변환하는 과정임. 대표적으로 바벨(Babel)과 같은 도구를 사용함.

**폴리필**은 오래된 자바스크립트 환경에서 지원하지 않는 **API**나 기능을 사용할 수 있도록, 해당 기능을 직접 구현하여 추가하는 패턴임.

트랜스파일러에 폴리필 기능이 내장되어 있는 경우가 많음.

참조 링크: [Babel 공식 문서](https://babeljs.io/)

### 문제 5: 자바스크립트의 실행 절차와 웹어셈블리

**질문:** 자바스크립트 소스 코드가 실행되는 일반적인 절차를 설명하고, 웹어셈블리(Wasm)가 자바스크립트 실행 과정에서 어떤 이점을 제공하는지 설명하세요.

**힌트:** 파싱, 컴파일, JIT 컴파일러, Wasm의 목적과 성능 향상.

**정답:**

- 자바스크립트 소스 코드는 다음과 같은 절차를 거쳐 실행됨:
    1. 코드를 바벨이 트랜스파일링함. 이후 웹팩 등의 번들러를 통해 번들링됨.
    2. 자바스크립트 엔진은 전달받은 코드를 파싱해 **추상 구문 트리(AST)**로 변환함.
    3. 엔진은 AST를 이진 바이트 코드로 변환하며, JIT 컴파일러가 작동하여 최적화됨.
    4. 최종적으로 자바스크립트 가상 머신이 코드를 실행함.
- **웹어셈블리(Wasm)**는 자바스크립트 엔진에서 고성능으로 실행되도록 설계된 이진 코드 포맷임. **파싱과 컴파일 과정이 필요 없으며**, 다른 언어로 작성된 코드를 **자바스크립트 환경에서 효율적으로 실행할 수 있게 해줌**. 이는 성능 향상을 위해 고안되었으며, 다양한 시스템 환경에서 크로스 플랫폼 가상 머신으로 진화하고 있음.

### 문제 6: 엄격 모드의 필요성과 적용 방법

**질문:** 자바스크립트에서 엄격 모드가 무엇인지 설명하고, 엄격 모드를 적용할 때 주의해야 할 점을 두 가지 이상 서술하세요.

**힌트:** `"use strict";` 구문 사용 위치, 함수 단위 vs 파일 단위 적용.

**정답:** 

- **엄격 모드**는 자바스크립트 코드의 실행을 더 엄격하게 관리하여, 오류를 사전에 방지하고 엔진의 최적화를 돕는 모드임. `"use strict";` 구문을 사용하여 활성화할 수 있음.
- **주의할 점**
    1. 파일 단위로 엄격 모드를 적용하려면 `"use strict";` 구문이 파일의 최상단에 위치해야 함. 구문 앞에 주석이나 공백 이외의 내용이 있으면 안 됨.
    2. 함수 단위로 엄격 모드를 적용할 경우, 파일 단위로 엄격 모드를 적용할 수 없다는 점을 주의해야 함. 기존 비엄격 모드 코드에 점진적으로 엄격 모드를 도입할 때 주로 사용됨.

참조 링크: [MDN Web Docs - Strict mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode)
